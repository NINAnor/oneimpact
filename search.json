[{"path":"https://ninanor.github.io/oneimpact/articles/oneimpact.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting started with the oneimpact package in R","text":"Anthropogenic disturbance often takes place landscapes already affected Infrastructure development land use change, leading cumulative impacts biodiversity. Typically, impact given type infrastructure determined computing distance nearest feature , ignoring potential cumulative impacts multiple features, can lead severe underestimations. oneimpact package collection tools functions intended aid estimation cumulative impacts ecological studies environmental impact assessments. version 0.1.0, main functions related calculation zone influence (ZoI) metrics based nearest influence cumulative influence multiple features given type infrastructure. calculating ZoI nearest feature cumulative ZoI multiple features using different ZoI shapes radii, possible use different metrics covariates ecological models evaluate strongly different infrastructure types affect ecological processes, impact spreads space, far reach, impact multiple features accumulate. approach described details Niebuhr et al. (submitted) exemplified document. discussion around impacts anthropogenic disturbance zone influence closely linked studies habitat amount fragmentation scale effect spatial variables species-habitat relationships, widely explored landscape ecology literature (e.g. Miguet et al., 2016; Huais, 2018). practical purposes, estimating ZoI anthropogenic disturbances similar estimating scale effect also taking account shape influence (.e. spatially weighted; Miguet et al., 2017). give overview functions oneimpact, define illustrate zone influence functions, show use main package functions, provide example use approach annotate data statistical analysis. install oneimpact package, possible use devtools::install_github() function: installed, now load oneimpact package packages used vignette.","code":"library(devtools) devtools::install_github(repo = \"NINAnor/oneimpact\", ref = \"HEAD\") library(oneimpact)  library(ggplot2) # for plots library(terra) # for spatial processing library(sf) # for spatial operations with vectors library(dplyr) # for data wrangling"},{"path":"https://ninanor.github.io/oneimpact/articles/oneimpact.html","id":"overview-of-the-package","dir":"Articles","previous_headings":"","what":"Overview of the package","title":"Getting started with the oneimpact package in R","text":"oneimpact package two main functions calculate zones influence, functions calc_zoi_nearest() calc_zoi_cumulative(). Alternatively function calc_zoi() can calculate ZoI metrics run. functions’ main arguments type, defines shape spatial decay ZoI, radius, defines far influence expands space (fast decreases distance). functions can run R environment (R Core Team, 2021) GRASS GIS environment (GRASS Development Team, 2017). defined parameter . one hand, computations R generally fast easy--use, since make use optimized functions terra package (Hijmans, 2022). However, computations might become slow large maps. hand, GRASS GIS, possible compute ZoI large maps using software’s compiled tools, given GRASS GIS store maps computer’s memory. GRASS GIS, calculation ZoI requires active connection R session GRASS GIS location mapset (package rgrass7; Bivand, 2022), input maps already loaded within GRASS GIS mapset. Furthermore, GRASS GIS function returns name output map. map stored GRASS GIS location/mapset, might retrieved R rgrass::read_RAST() function exported outside GRASS using r..gdal module, instance. ZoI nearest feature (output calc_zoi_nearest()) based transformations map distance nearest feature. First, map computed terra::distance() function R r.grow.distance module GRASS. , ZoI functions applied transform maps zones influence. zone influence functions implemented oneimpact shown Table 1 might explored command help(zoi_functions). might also plotted 1 dimensional space plot_zoi1d() function, illustration behavior. Table 1: Main functions oneimpact used calculate zones influence. divided three types: zone influence functions (“ZoI functions”), functions compute ZoI raster maps (“Compute ZoI”), functions create filters weight matrices use computation cumulative ZoI (“Create filters”). cumulative ZoI multiple features (output calc_zoi_cumulative()) based neighborhood analysis using spatial filters determine ZoI functions. ZoI functions might used calc_zoi_nearest() calc_zoi_cumulative(), accounting different ZoI shapes radii, latter used create weight matrices input neighborhood analysis. function already built-choices ZoI functions determine weight matrix. weight matrices might created function filter_create(). function calc_zoi_cumulative() computes neighborhood analysis terra::focal() function R one modules GRASS GIS: r.mfilter, r.resamp.filter, r.neighbors. module used might determined user (parameter module).","code":""},{"path":"https://ninanor.github.io/oneimpact/articles/oneimpact.html","id":"the-concept-of-zone-of-influence","dir":"Articles","previous_headings":"","what":"The concept of zone of influence","title":"Getting started with the oneimpact package in R","text":"zone influence (ZoI) function \\(\\phi\\) informs impact given infrastructure feature, source disturbance, landscape element decreases distance. Formally, ZoI \\(\\phi = f(d, r)\\) decay function maximum value 1 disturbance located, decreases towards zero distance \\(d\\) increases, possibly vanishes given point, ZoI radius \\(r\\). Broadly speaking, ZoI characterized shape radius. Four sets functions implemented oneimpact: threshold decay, linear decay, exponential decay, Gaussian decay. functions present definition multiple function names, accommodate different algorithms call functions (e.g. linear_decay() bartlett_decay() represent function).","code":""},{"path":[]},{"path":"https://ninanor.github.io/oneimpact/articles/oneimpact.html","id":"functions-with-a-well-defined-zoi-radius","dir":"Articles","previous_headings":"The concept of zone of influence > ZoI functions","what":"Functions with a well-defined ZoI radius","title":"Getting started with the oneimpact package in R","text":"functions vanish certain non-infinite distance therefore present well-defined ZoI radii. ZoI radius \\(r\\) represents distance \\(\\phi = 0\\). Two functions type implemented oneimpact: threshold linear decay functions.","code":""},{"path":"https://ninanor.github.io/oneimpact/articles/oneimpact.html","id":"threshold-decay-function","dir":"Articles","previous_headings":"The concept of zone of influence > ZoI functions > Functions with a well-defined ZoI radius","what":"Threshold decay function","title":"Getting started with the oneimpact package in R","text":"threshold function constant distance \\(d\\) infrastructure source disturbance smaller ZoI radius \\(r\\), zero beyond . can computed using threshold_decay() step_decay() functions: visualize function shape 1 dimension space, make use function plot_zoi1d(). plot assumes source disturbance located \\(x = 0\\) distance increases sides x axis: Illustration threshold decay ZoI ZoI radius = 10.","code":"# threshold ZoI with radius = 10 threshold_decay(5, radius = 10) # within the radius #> [1] 1 threshold_decay(10, radius = 10) # at or beyond the radius #> [1] 0 # threshold ZoI with radius = 10 plot_zoi1d(points = 0, radius = 10, fun = threshold_decay, range_plot = c(-20, 20))"},{"path":"https://ninanor.github.io/oneimpact/articles/oneimpact.html","id":"linear-decay-function","dir":"Articles","previous_headings":"The concept of zone of influence > ZoI functions > Functions with a well-defined ZoI radius","what":"Linear decay function","title":"Getting started with the oneimpact package in R","text":"linear decay (also Bartlett tent decay) function decreases linearly distance \\(d\\) infrastructure source disturbance becomes zero beyond ZoI radius \\(r\\). can computed using following functions: linear_decay(), bartlett_decay, tent_decay(). show use function: visualize function shape 1 dimension space using function plot_zoi1d(): Illustration linear decay ZoI ZoI radius = 10.","code":"# linear decay ZoI with radius = 10 linear_decay(5, radius = 10) # within the radius #> [1] 0.5 linear_decay(10, radius = 10) # at or beyond the radius #> [1] 0 # threshold ZoI with radius = 10 plot_zoi1d(points = 0, radius = 10, fun = linear_decay, range_plot = c(-20, 20))"},{"path":"https://ninanor.github.io/oneimpact/articles/oneimpact.html","id":"functions-that-do-not-vanish-with-distance","dir":"Articles","previous_headings":"The concept of zone of influence > ZoI functions","what":"Functions that do not vanish with distance","title":"Getting started with the oneimpact package in R","text":"functions decrease vanish distance infrastructure increases. cases define ZoI radius \\(r\\) distance ZoI decreases \\(\\phi = \\phi_{limit}\\), arbitrary small ZoI value beyond influence infrastructure considered negligible. cases, ZoI definition needs extra parameter defined \\(\\phi = f(d, r, \\phi_{limit})\\). Two functions type implemented oneimpact: exponential decay Gaussian decay functions.","code":""},{"path":"https://ninanor.github.io/oneimpact/articles/oneimpact.html","id":"exponential-decay-function","dir":"Articles","previous_headings":"The concept of zone of influence > ZoI functions > Functions that do not vanish with distance","what":"Exponential decay function","title":"Getting started with the oneimpact package in R","text":"exponential decay function decays exponentially distance \\(d\\) infrastructure, rate decay set \\(\\phi = \\phi_{limit}\\) ZoI radius (\\(d = r\\)). exponential decay might calculated using exp_decay() function: possible see, exponential decay ZoI radius = 10 imply function null beyond ZoI radius, goes zoi_limit. default, zoi_limit = 0.05, value might changed user (e.g. 0.01 small value). Changing zoi_limit changes interpretation ZoI radius parameter, though: visualize function shape 1 dimension space: Illustration exponential decay ZoI ZoI radius = 10 ZoI limit = 0.05. Illustration exponential decay ZoI ZoI radius = 10 ZoI limit = 0.05. add plot horizontal dashed line zoi_limit = 0.05 vertical dashed lines x = 10 x = -10 (since radius = 10), show ZoI radius represent distance ZoI reaches zoi_limit.","code":"# exponential decay ZoI with radius = 10 exp_decay(5, radius = 10) # within the radius #> [1] 0.2236068 exp_decay(10, radius = 10) # at the radius #> [1] 0.05 exp_decay(15, radius = 10) # beyond the radius #> [1] 0.01118034 # changing zoi_limit changes the interpretation of radius exp_decay(5, radius = 10, zoi_limit = 0.01) # within the radius #> [1] 0.1 exp_decay(10, radius = 10, zoi_limit = 0.01) # at the radius #> [1] 0.01 exp_decay(15, radius = 10, zoi_limit = 0.01) # beyond the radius #> [1] 0.001 # threshold ZoI with radius = 10 plot_zoi1d(points = 0, radius = 10, fun = exp_decay, range_plot = c(-20, 20)) +   geom_hline(yintercept = 0.05, linetype = 2, color = \"grey\") +   geom_vline(xintercept = c(-10, 10), linetype = 2, color = \"grey\")"},{"path":"https://ninanor.github.io/oneimpact/articles/oneimpact.html","id":"gaussian-decay-function","dir":"Articles","previous_headings":"The concept of zone of influence > ZoI functions > Functions that do not vanish with distance","what":"Gaussian decay function","title":"Getting started with the oneimpact package in R","text":"Gaussian (half-normal) decay function decays following half normal shape, rate decay set \\(\\phi = \\phi_{limit}\\) ZoI radius (\\(d = r\\)). Gaussian decay might calculated using gaussian_decay() half_norm_decay() functions: visualize function shape 1 dimension space: Illustration Gaussian decay ZoI ZoI radius = 10 ZoI limit = 0.05. Illustration Gaussian decay ZoI ZoI radius = 10 ZoI limit = 0.05. Notice , even though ZoI radius \\(r\\) defined functions, change shape strongly modifies interpretation ZoI changes distance. functions set might used calculate ZoI nearest feature define weight matrices calculate cumulative ZoI multiple features.","code":"# Gaussian decay ZoI with radius = 10 gaussian_decay(5, radius = 10) # within the radius #> [1] 0.4728708 gaussian_decay(10, radius = 10) # at or beyond the radius #> [1] 0.05 gaussian_decay(15, radius = 10) # at or beyond the radius #> [1] 0.001182177 # threshold ZoI with radius = 10 plot_zoi1d(points = 0, radius = 10, fun = gaussian_decay, range_plot = c(-20, 20)) +   geom_hline(yintercept = 0.05, linetype = 2, color = \"grey\") +   geom_vline(xintercept = c(-10, 10), linetype = 2, color = \"grey\")"},{"path":"https://ninanor.github.io/oneimpact/articles/oneimpact.html","id":"zoi-metrics","dir":"Articles","previous_headings":"The concept of zone of influence","what":"ZoI metrics","title":"Getting started with the oneimpact package in R","text":"Given ZoI function set specific shape ZoI radius, two metrics might calculated zone influence: ZoI nearest feature alone cumulative ZoI multiple features. exemplify difference, illustrate using Gaussian decay ZoI 1 dimension space using plot_zoi1d() function. set four sources disturbance (e.g. houses) located x = 0, x = 2, x = 8, x = 12, set ZoI radius feature radius = 3. start plotting ZoI nearest feature alone setting zoi_metric = \"nearest\":  location disturbance sources shown vertical dashed lines. Notice maximum value ZoI nearest feature 1. Now considering ZoI feature accumulates. setting zoi_metric = \"cumulative\" plot_zoi1d():  Notice maximum value cumulative ZoI multiple features might higher 1 ZoI different features overlap.","code":"disturbance_locations <- c(0, 2, 8, 12) plot_zoi1d(points = disturbance_locations, radius = 3, fun = gaussian_decay,            zoi_metric = \"nearest\", range_plot = c(-10, 20)) +   labs(x = \"Space\") +   geom_vline(xintercept = disturbance_locations, linetype = 2, color = \"grey\") plot_zoi1d(points = disturbance_locations, radius = 3, fun = gaussian_decay,            zoi_metric = \"cumulative\", range_plot = c(-10, 20)) +   labs(x = \"Space\") +   geom_vline(xintercept = disturbance_locations, linetype = 2, color = \"grey\")"},{"path":[]},{"path":"https://ninanor.github.io/oneimpact/articles/oneimpact.html","id":"define-the-input-raster-map","dir":"Articles","previous_headings":"Calculating the ZoI metrics for rasters","what":"Define the input raster map","title":"Getting started with the oneimpact package in R","text":"calculate ZoI metrics 2 dimensional raster objects, use functions calc_zoi_nearest() calc_zoi_cumulative(). give example, present data set location private cabins Norway, subset small study region Southern Norway. data mapped points vector format; information might found using command help(cabins_vect.gpkg). read vector file using package terra: Location private cabins study area Souther Norway. input map already raster format, can used directly calc_zoi_*() functions. case, since vector format, must rasterized first. many types anthropogenic infrastructure disturbance represented lines polygons (e.g. roads, power lines, areas deforestation), enough create binary raster dummy variable value 1 disturbance located 0 (NA) elsewhere. point representation infrastructure, though, might interesting count number features per pixel. create raster number cabins per pixel, use function terra::rasterize() parameter \\(\\verb|fun = length|\\). load another raster 100 m resolution area use grid rasterization process. Raster number private cabins per pixel, used input calculating ZoI metrics. map presents number cabins pixel NA cabins. GRASS GIS, possible use ancillary oneimpact function grass_v2rast_count() count number features vector pixel get output raster object.","code":"# file path s <- system.file(\"vector/cabins_vect.gpkg\", package = \"oneimpact\") # read file cabins_vect <- terra::vect(s) # check cabins_vect #>  class       : SpatVector  #>  geometry    : points  #>  dimensions  : 6875, 4  (geometries, attributes) #>  extent      : 146900.1, 194694.6, 6622822, 6658891  (xmin, xmax, ymin, ymax) #>  source      : cabins_vect.gpkg #>  coord. ref. : ETRS89 / UTM zone 33N (EPSG:25833)  #>  names       :    cat byggtyp_nbr kommune value #>  type        :  <int>       <chr>   <int> <int> #>  values      : 131621         161     604     1 #>                131623         161     604     1 #>                131627         161     604     1 # plot plot(cabins_vect, cex = 0.5) # load grid s2 <- system.file(\"raster/cabins.tif\", package = \"oneimpact\") grid <- terra::rast(s2) # rasterize cabins_rast <- terra::rasterize(cabins_vect, grid, fun = length) cabins_rast #> class       : SpatRaster  #> dimensions  : 361, 478, 1  (nrow, ncol, nlyr) #> resolution  : 100, 100  (x, y) #> extent      : 146900, 194700, 6622800, 6658900  (xmin, xmax, ymin, ymax) #> coord. ref. : +proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs  #> source      : memory  #> name        : cabins  #> min value   :      1  #> max value   :      8 # plot plot(cabins_rast)"},{"path":"https://ninanor.github.io/oneimpact/articles/oneimpact.html","id":"calculate-the-zoi-of-the-nearest-feature-only","dir":"Articles","previous_headings":"Calculating the ZoI metrics for rasters","what":"Calculate the ZoI of the nearest feature only","title":"Getting started with the oneimpact package in R","text":"map might used input calc_zoi_nearest(). function, important background input raster map (pixels cabins) NA (-data). calculate ZoI nearest feature using Gaussian shaped ZoI radius = 1000 m. default, computation done R (parameter \\(\\verb|= \"R\"|\\)). Zone influence nearest feature private cabins, using Gaussian ZoI radius = 1000 m. shape ZoI might changed parameter type, using functions presented . parameter might also set \\(\\verb|type = \"euclidean\"|\\) computation Euclidean distance nearest feature \"log\" \"sqrt\" log- sqrt-transformed distance nearest feature.","code":"# calculate ZoI cabins_nearest <- calc_zoi_nearest(cabins_rast, radius = 1000, type = \"Gauss\") # plot plot(cabins_nearest)"},{"path":"https://ninanor.github.io/oneimpact/articles/oneimpact.html","id":"calculate-the-cumulative-zoi-of-multiple-features","dir":"Articles","previous_headings":"Calculating the ZoI metrics for rasters","what":"Calculate the cumulative ZoI of multiple features","title":"Getting started with the oneimpact package in R","text":"Differently calc_zoi_nearest(), input raster map calc_zoi_cumulative() present zeros background (pixels cabins). R, background NA values might checked reclassified zero using \\(\\verb|zeroAsNA = TRUE|\\) parameter, GRASS GIS implemented case, easiest procedure prepare input raster map outside GRASS make use module r.null managing -data values rasters within GRASS. calculate cumulative ZoI multiple features using setup – Gaussian shaped ZoI radius = 1000 m. Cumulative zone influence multiple features private cabins, using Gaussian ZoI radius = 1000 m. Notice output map differs considerably ZoI nearest feature . shape ZoI might also changed parameter type, using functions presented . Alternatively, customized weight matrix might defined user used radius parameter, case user must set \\(\\verb|type = \"mfilter\"|\\). functions define weight matrices might set e.g. terra::focalMat() (Hijmans, 2022) smoothie::kernel2dmeitsjer() (Gilleland, 2013) functions. Notice, however, functions parameterized differently, reference ZoI radius ones defined oneimpact. calc_zoi_cumulative(), user might choose computing cumulative ZoI metric \\(\\verb|output_type = \"cumulative_zoi\"|\\) (default), density features \\(\\verb|output_type = \"density\"|\\). cumulative ZoI (distance weighted) number features per unit space, might assumes values much higher one features located closer ZoI (see Figs. D6 D10). calculation density features, hand, occurs normalization weight matrix, values sum 1. consequence, density features generally presents values lower close 1. measures represent spatial variation, interpretation values different.","code":"# calculate ZoI cabins_cumul <- calc_zoi_cumulative(cabins_rast, radius = 1000, type = \"gaussian_decay\",                                     zeroAsNA = TRUE) # plot plot(cabins_cumul)"},{"path":"https://ninanor.github.io/oneimpact/articles/oneimpact.html","id":"using-the-zoi-approach-to-annotate-and-analyze-data","dir":"Articles","previous_headings":"","what":"Using the ZoI approach to annotate and analyze data","title":"Getting started with the oneimpact package in R","text":"cumulative impact assessment proposed oneimpact, calculation ZoI (\\(\\phi\\)) done statistical analysis. formulation, \\(\\phi\\) defined based different shapes radii considered different covariates (Fig. D). Therefore, evaluation impact multiple infrastructure features accumulate identification ZoI shape radius recasted model selection rather parameterization problem. Workflow calculating infrastructure ZoI estimating cumulative impact ZoI radius multiple infrastructure. Infrastructure raster data input calc_zoi_*() functions, allow calculation ZoI nearest feaure cumulative ZoI based arguments ZoI shape radius. output influence rasters environmental data annotated biological data, infrastructure type ZoI metric defined shape radius considered different covariate. annotated data analyzed estimate effect size Zoi radius infrastructure type calculate impact . Figure D shows workflow calculating ZoI metrics using annotate biological data estimation cumulative impacts. calculation ZoI nearest feature cumulative ZoI might done different ZoI shapes, radii, infrastructure type, combinations turn different covariate annotated biological data ecological modeling. simulate data set sampling points theoretical random biological response variable show process calculation ZoI variables annotation biological data. First create study area \\(n = 40\\) random locations representing sampling points given response variable z (e.g. species richness abundance). sample locations using set_points() function package oneimpact simulate response variable z Poisson distributed random variable mean \\(\\lambda = 10\\). simulated sampled data shown Fig. D. Simulated sampling points (red) study area. Black dots represent location private cabins. Now use procedure presented calculate ZoI nearest feature cumulative ZoI different radii. use exponential decay ZoI vary ZoI radius 500 m 1500 m. can combine ZoI variables visualize : ZoI nearest cabin cumulative ZoI multiple cabins exponential decay ZoI radius = 500, 1000, 1500 m. Finally, ZoI variables can used annotate biological data statistical analysis. point, biological data can also annotated ZoI disturbance variables environmental covariates used input estimation effect sizes \\(\\beta\\) evaluation cumulative effects different types infrastructure statistical models (Fig. D) Statistical analyses can make use model selection (Burnham & Anderson, 2002; Jackson & Fahrig, 2015; Huais, 2018), penalized regression (Lee et al., 2020), machine learning approaches, example (James et al., 2021). statistical modeling procedures beyond scope oneimpact.","code":"# get extent of the study area extent <- terra::ext(cabins_rast) # sample n = 40 random locations and simulate biological data bio_data <- set_points(40, method = \"random\", res = 100,                         extent_x = extent[c(1,2)], extent_y = extent[c(3,4)]) %>%   .$pts %>% # get only coordinates   sf::st_as_sf(coords = c(1,2), crs = crs(cabins_rast)) %>% # change to sf object   dplyr::mutate(id = 1:40, z = rpois(40, lambda = 10)) %>% # add id and simulate response z    terra::vect() # transform to vect to use with SpatRaster object # plot plot(cabins_vect, cex = 0.5) plot(bio_data, col = \"red\", add = T) # radii radii <- c(500, 1000, 1500) # exp decay ZoI - nearest zoi_exp_nearest <- calc_zoi_nearest(cabins_rast, radius = radii,                                     type = \"exp_decay\") # exp decay ZoI - cumulative zoi_exp_cumul <- calc_zoi_cumulative(cabins_rast, radius = radii,                                      type = \"exp_decay\", zeroAsNA = TRUE) # combine ZoI variables zoi_all <- c(zoi_exp_nearest, zoi_exp_cumul) # plot plot(zoi_all) # extract values zoi_sampling_pts <- terra::extract(zoi_all, bio_data) # combine response variable with extracted data bio_data_annotated <- dplyr::left_join(as.data.frame(bio_data, geom = \"XY\"),                                         zoi_sampling_pts, by = c(\"id\" = \"ID\")) # show annotated data head(bio_data_annotated) #>   id  z        x       y zoi_nearest_exp_decay500 zoi_nearest_exp_decay1000 #> 1  1 15 171065.0 6650720              0.004705944                0.06859989 #> 2  2 14 167603.5 6626683              0.002220287                0.04711992 #> 3  3  9 180585.1 6642674              0.005981347                0.07733917 #> 4  4  7 168270.9 6626799              0.003990426                0.06316982 #> 5  5  4 192767.6 6655323              0.007149676                0.08455576 #> 6  6  3 190188.4 6645511              0.021570920                0.14687042 #>   zoi_nearest_exp_decay1500 zoi_cumulative_exp_decay500 #> 1                 0.1675775                 0.004705944 #> 2                 0.1304577                 0.000000000 #> 3                 0.1815236                 0.005981347 #> 4                 0.1586134                 0.003990426 #> 5                 0.1926469                 0.028105402 #> 6                 0.2783703                 0.035926034 #>   zoi_cumulative_exp_decay1000 zoi_cumulative_exp_decay1500 #> 1                   0.13273806                    0.5423492 #> 2                   0.07812371                    0.3391487 #> 3                   0.07733917                    0.1876144 #> 4                   0.08480047                    0.3352618 #> 5                   0.59669363                    1.8718118 #> 6                   0.69210981                    2.5845671"},{"path":"https://ninanor.github.io/oneimpact/articles/oneimpact.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Getting started with the oneimpact package in R","text":"Bivand, R. (2022). rgrass7: Interface GRASS Geographical Information System R. R package version 0.2-10. https://CRAN.R-project.org/package=rgrass7 Burnham, K. P., & Anderson, D. R. (2002). Model selection multimodel inference: practical information-theoretic approach (2nd ed). Springer. Gilleland, E. (2013). Two-dimensional kernel smoothing: Using R package smoothie. NCAR Technical Note, TN-502+STR, 17pp., doi:10.5065/D61834G2. GRASS Development Team (2017) Geographic Resources Analysis Support System (GRASS GIS) Software, Version 7.8. Open Source Geospatial Foundation. Hijmans, R. J. (2022). terra: Spatial Data Analysis. R package version 1.5-21. https://CRAN.R-project.org/package=terra Huais, P. Y. (2018). multifit: R function multi-scale analysis landscape ecology. Landscape Ecology, 33(7), 1023–1028. https://doi.org/10.1007/s10980-018-0657-5 Jackson, H. B., & Fahrig, L. (2015). ecologists conducting research optimal scale? Global Ecology Biogeography, 24(1), 52–63. https://doi.org/10.1111/geb.12233 James, G., Witten, D., Hastie, T., & Tibshirani, R. (2021). introduction statistical learning: applications R (Second edition). Springer. Lee, Y., Alam, M., Sandström, P., & Skarin, . (2020). Estimating zones influence using threshold regression. Working Papers Transport, Tourism, Information Technology Microdata Analysis, 2020:01, 1–16. Miguet, P., Jackson, H. B., Jackson, N. D., Martin, . E., & Fahrig, L. (2016). determines spatial extent landscape effects species? Landscape Ecology, 31(6), 1177–1194. https://doi.org/10.1007/s10980-015-0314-1 Miguet, P., Fahrig, L., & Lavigne, C. (2017). quantify distance‐dependent landscape effect biological response. Methods Ecology Evolution, 8(12), 1717–1724. https://doi.org/10.1111/2041-210X.12830 Niebuhr, B. B., van Moorter, B., Stien, ., Tveraa, T., Strand, O., Langeland, K., Alam, M., Skarin, ., & Panzacchi, M. Estimating cumulative impact zone influence anthropogenic infrastructure biodiversity. Submitted manuscript. R Core Team (2021). R: language environment statistical computing. R Foundation Statistical Computing, Vienna, Austria. https://www.R-project.org/.","code":""},{"path":"https://ninanor.github.io/oneimpact/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Bernardo Niebuhr. Author, maintainer. Manuela Panzacchi. Author. Bram van Moorter. Author.","code":""},{"path":"https://ninanor.github.io/oneimpact/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Niebuhr, B. B., Moorter, B. V., Stien, ., Tveraa, T., Strand, O., Langeland, K., Sandstrom, P., Alam, M., Skarin, ., & Panzacchi, M. (2022). Estimating cumulative impact zone influence anthropogenic infrastructure biodiversity. https://www.biorxiv.org/content/10.1101/2022.06.14.495994v1","code":"@Article{,   title = {Estimating the cumulative impact and zone of influence of anthropogenic infrastructure on biodiversity},   author = {Bernardo B. Niebuhr and Bram {van Moorter} and Audun Stien and Torkild Tveraa and Olav Strand and Knut Langeland and Per Sandström and Moudud Alam and Anna Skarin and Manuela Panzacchi},   journal = {bioRxiv},   year = {2022},   volume = {2022.06.14.495994},   url = {https://doi.org/10.1101/2022.06.14.495994}, }"},{"path":"https://ninanor.github.io/oneimpact/index.html","id":"oneimpact-","dir":"","previous_headings":"","what":"Tools for the assessment of cumulative impacts of anthropogenic \n    disturbance on ecological studies","title":"Tools for the assessment of cumulative impacts of anthropogenic \n    disturbance on ecological studies","text":"oneimpact provides tools assessment cumulative impacts multiple infrastructure land use modification ecological studies. tools use R interface main calculations might run R GRASS GIS. tools available far :","code":""},{"path":"https://ninanor.github.io/oneimpact/index.html","id":"zone-of-influence-zoi-decay-functions","dir":"","previous_headings":"","what":"Zone of influence (ZoI) decay functions","title":"Tools for the assessment of cumulative impacts of anthropogenic \n    disturbance on ecological studies","text":"zoi_functions: set decay zone influence functions characterize different shapes ZoI around infrastructure, parameterized based zone influence radius. functions implemented far : threshold (threshold_decay step_decay), linear decay (linear_decay bartlett_decay tent_decay), exponential decay (exp_decay), Gaussian decay (gaussian_decay half_norm_decay). plot_zoi1d: plot ZoI 1 dimensional space multiple points infrastructure, using ZoI nearest feature cumulative ZoI metric.","code":""},{"path":"https://ninanor.github.io/oneimpact/index.html","id":"compute-zones-of-influence-zoi","dir":"","previous_headings":"","what":"Compute zones of influence (ZoI):","title":"Tools for the assessment of cumulative impacts of anthropogenic \n    disturbance on ecological studies","text":"calc_zoi_nearest: Calculate zone influence nearest infrastructure, according multiple possible decay functions zones influence radii. calc_zoi_cumulative: Calculate cumulative zone influence multiple features, according multiple possible decay functions zones influence radii. calc_zoi: Calculate ZoI nearest infrastructure cumulative ZoI, multiple scales zones influence radii.","code":""},{"path":"https://ninanor.github.io/oneimpact/index.html","id":"spatial-filters","dir":"","previous_headings":"","what":"Spatial filters:","title":"Tools for the assessment of cumulative impacts of anthropogenic \n    disturbance on ecological studies","text":"create_filter: Create filters weight matrices neighborhood analysis, according different decay functions parameterized using zone influence radius. save_filter: Saves filters/weight matrices outside R use within GRASS GIS modules.","code":""},{"path":"https://ninanor.github.io/oneimpact/index.html","id":"ancillary-functions","dir":"","previous_headings":"","what":"Ancillary functions:","title":"Tools for the assessment of cumulative impacts of anthropogenic \n    disturbance on ecological studies","text":"grass_binarize: Binarize continuous multi-class categorical rasters within GRASS GIS. Binary maps may used input cumulative zone influence kernel density calculation. grass_v2rast_count: Rasterize vector files counting number features within pixel output raster. Count rasters may used input cumulative zone influence kernel density calculation.","code":""},{"path":"https://ninanor.github.io/oneimpact/index.html","id":"support-for-landscape-simulation","dir":"","previous_headings":"","what":"Support for landscape simulation:","title":"Tools for the assessment of cumulative impacts of anthropogenic \n    disturbance on ecological studies","text":"set_points: simulate points landscape according different rules spatial patterns.","code":""},{"path":"https://ninanor.github.io/oneimpact/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Tools for the assessment of cumulative impacts of anthropogenic \n    disturbance on ecological studies","text":"install development version oneimpact R package, please use:","code":"library(devtools) devtools::install_github(\"NINAnor/oneimpact\", ref = \"HEAD\")"},{"path":"https://ninanor.github.io/oneimpact/index.html","id":"see-also","dir":"","previous_headings":"","what":"See also","title":"Tools for the assessment of cumulative impacts of anthropogenic \n    disturbance on ecological studies","text":"oneimpact functions greatly based neighborhood analyses made terra package R three GRASS GIS modules: r.mfilter, r.resamp.filter, r.neighbors. connection R GRASS GIS made rgrass7 R package.","code":""},{"path":"https://ninanor.github.io/oneimpact/index.html","id":"meta","dir":"","previous_headings":"","what":"Meta","title":"Tools for the assessment of cumulative impacts of anthropogenic \n    disturbance on ecological studies","text":"Please report issues bugs. License: GPL3 Get citation information oneimpact R running citation(package = 'oneimpact') Contributions mostly welcome!","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/cabins.tif.html","id":null,"dir":"Reference","previous_headings":"","what":"Cabin presence raster data — cabins.tif","title":"Cabin presence raster data — cabins.tif","text":"Raster data indicating pixels presence tourist private cabins Norway. corresponds specific building types (object_type = \"Bygning\", byggtyp_nbr = c(\"161\", \"162\", \"163\")) form public N50 dataset. original data consisted point vector data rasterized 100m r esolution, purpose illustration . raster cut study area presented oneimpact package.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/cabins.tif.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Cabin presence raster data — cabins.tif","text":"Geotiff file. Projected CRS: ETRS89 / UTM zone 33N. 1: Presence cabins NA: presence cabins","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/cabins.tif.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Cabin presence raster data — cabins.tif","text":"https://register.geonorge./det-offentlige-kartgrunnlaget/n50-kartdata/ea192681-d039-42ec-b1bc-f3ce04c189ac","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/cabins.tif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cabin presence raster data — cabins.tif","text":"","code":"(f <- system.file(\"raster/cabins.tif\", package = \"oneimpact\")) #> [1] \"/home/runner/work/_temp/Library/oneimpact/raster/cabins.tif\" terra::rast(f) #> class       : SpatRaster  #> dimensions  : 361, 478, 1  (nrow, ncol, nlyr) #> resolution  : 100, 100  (x, y) #> extent      : 146900, 194700, 6622800, 6658900  (xmin, xmax, ymin, ymax) #> coord. ref. : +proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs  #> source      : cabins.tif  #> name        : cabins  #> min value   :      1  #> max value   :      1"},{"path":"https://ninanor.github.io/oneimpact/reference/cabins_count.tif.html","id":null,"dir":"Reference","previous_headings":"","what":"Cabin count raster data — cabins_count.tif","title":"Cabin count raster data — cabins_count.tif","text":"Raster data indicating number tourist private cabins per pixel Norway. corresponds specific building types (object_type = \"Bygning\", byggtyp_nbr = c(\"161\", \"162\", \"163\")) form public N50 dataset. original data consisted point vector data rasterized 100m resolution counting number cabins pixel. raster cut study area presented oneimpact package.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/cabins_count.tif.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Cabin count raster data — cabins_count.tif","text":"Geotiff file. Projected CRS: ETRS89 / UTM zone 33N.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/cabins_count.tif.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Cabin count raster data — cabins_count.tif","text":"https://register.geonorge./det-offentlige-kartgrunnlaget/n50-kartdata/ea192681-d039-42ec-b1bc-f3ce04c189ac","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/cabins_count.tif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cabin count raster data — cabins_count.tif","text":"","code":"(f <- system.file(\"raster/cabins_count.tif\", package = \"oneimpact\")) #> [1] \"/home/runner/work/_temp/Library/oneimpact/raster/cabins_count.tif\" terra::rast(f) #> class       : SpatRaster  #> dimensions  : 361, 478, 1  (nrow, ncol, nlyr) #> resolution  : 100, 100  (x, y) #> extent      : 146900, 194700, 6622800, 6658900  (xmin, xmax, ymin, ymax) #> coord. ref. : +proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs  #> source      : cabins_count.tif  #> name        : cabins  #> min value   :      0  #> max value   :      8"},{"path":"https://ninanor.github.io/oneimpact/reference/cabins_vect.gpkg.html","id":null,"dir":"Reference","previous_headings":"","what":"Cabins vector data — cabins_vect.gpkg","title":"Cabins vector data — cabins_vect.gpkg","text":"Dataset containing location tourist private cabins Southern Norway, within study area oneimpact package. corresponds specific building types (object_type = \"Bygning\", byggtyp_nbr = c(\"161\", \"162\", \"163\")) form public N50 dataset. map cut study area presented oneimpact package.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/cabins_vect.gpkg.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Cabins vector data — cabins_vect.gpkg","text":"geopackage file. Projected CRS: ETRS89 / UTM zone 33N. vector file presents following columns: cat: Line number, corresponding original dataset byggtyp_nbr: Type building (code) original dataset kommune: Code municipality cabin located value: Value 1, used rasterization purposes","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/cabins_vect.gpkg.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Cabins vector data — cabins_vect.gpkg","text":"https://register.geonorge./det-offentlige-kartgrunnlaget/n50-kartdata/ea192681-d039-42ec-b1bc-f3ce04c189ac","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/cabins_vect.gpkg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cabins vector data — cabins_vect.gpkg","text":"","code":"(s <- system.file(\"vector/cabins_vect.gpkg\", package = \"oneimpact\")) #> [1] \"/home/runner/work/_temp/Library/oneimpact/vector/cabins_vect.gpkg\" sf::st_read(s) #> Reading layer `cabins_vect' from data source  #>   `/home/runner/work/_temp/Library/oneimpact/vector/cabins_vect.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 6875 features and 4 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 146900.1 ymin: 6622822 xmax: 194694.6 ymax: 6658891 #> Projected CRS: ETRS89 / UTM zone 33N # or terra::vect(s) #>  class       : SpatVector  #>  geometry    : points  #>  dimensions  : 6875, 4  (geometries, attributes) #>  extent      : 146900.1, 194694.6, 6622822, 6658891  (xmin, xmax, ymin, ymax) #>  source      : cabins_vect.gpkg #>  coord. ref. : ETRS89 / UTM zone 33N (EPSG:25833)  #>  names       :    cat byggtyp_nbr kommune value #>  type        :  <int>       <chr>   <int> <int> #>  values      : 131621         161     604     1 #>                131623         161     604     1 #>                131627         161     604     1"},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates the zone of influence from the nearest feature\nand the cumulative zone of influence of multiple features — calc_zoi","title":"Calculates the zone of influence from the nearest feature\nand the cumulative zone of influence of multiple features — calc_zoi","text":"function takes raster locations infrastructure calculates (1) raster representing distance pixel neareast feature (2) raster (set rasters, case one value scale) representing density features space (spatial filter/neighborhood analysis). neighborhood analysis done raster::focal() function.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates the zone of influence from the nearest feature\nand the cumulative zone of influence of multiple features — calc_zoi","text":"","code":"calc_zoi(   x,   zoi_metric = c(\"all\", \"nearest\", \"cumulative\")[1],   where = c(\"R\", \"GRASS\")[1],   ... )"},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates the zone of influence from the nearest feature\nand the cumulative zone of influence of multiple features — calc_zoi","text":"x [RasterLayer,SpatRaster]  Raster representing locations features, preferentially positive value features located NA elsewhere. Alternatively, x might binary (dummy) spatial variable representing presence linear area features, NA/-data background. x can RasterLayer raster package SpatRaster terra package. = \"GRASS\", x must string corresponding name input map within GRASS GIS location mapset. input raster x positive values pixels infrastructure located NA/-data places. R also possible zeros background set zeroAsNA = TRUE computation ZoI nearest feature. GRASS, maps without NA background might prepared input calc_zoi_nearest() raster algebra e.g. use module r.null. zoi_metric [character(1)=\"\"]{\"\", \"nearest\", \"cumulative\"}  metric zone influence computed. Either \"\", \"nearest\", \"cumulative\". [character(1)=\"R\"]{\"R\", \"GRASS\"}  computation done? Default \"R\". = \"GRASS\", R session must linked open GRASS GIS session specific location mapset. ... Adittional parameters passed terra::distance() ZoI functions (see zoi_functions()) calculations performed R. additional parameters implemented computation GRASS GIS.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates the zone of influence from the nearest feature\nand the cumulative zone of influence of multiple features — calc_zoi","text":"RasterBrick de distance nearest feature densities scales selected.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculates the zone of influence from the nearest feature\nand the cumulative zone of influence of multiple features — calc_zoi","text":"neighborhood analysis can done different methods. default Gaussian filter (type_density = \"Gauss\"), case scale corresponds sigma paramater Gaussian filter. type_density = \"circle\" type_density = \"rectangle\", scale corresponds radius circle width rectangle, respectively. See raster::focalWeight() details. IMPROVE2: communication GRASS GIS.","code":""},{"path":[]},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates the zone of influence from the nearest feature\nand the cumulative zone of influence of multiple features — calc_zoi","text":"","code":"library(terra) #> terra 1.6.7"},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi_cumulative.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the cumulative zone of influence of multiple features — calc_zoi_cumulative","title":"Calculate the cumulative zone of influence of multiple features — calc_zoi_cumulative","text":"function takes raster locations counts infrastructure calculates raster (set rasters, case one value radius) representing cumulative zone influence (ZoI) density features space. process done spatial filter/moving window/neighborhood analysis. ZoI weight matrix defined zone influence functions, might follow different shapes cover area according ZoI radius. details, see zoi_functions(). procedure might computed R GRASS GIS. R, neighborhood analysis done terra::focal() function. GRASS, different modules might used computation: r.resamp.filter, r.mfilter, r.neighbors. See details differences. GRASS, requires active connection R session GRASS GIS location mapset (package rgrass7), input maps already loaded within GRASS GIS mapset. calculations done R, input (set ) raster map(s) function returns another (set ) raster map(s). calculations done within GRASS GIS, input name raster map already loaded GRASS GIS location mapset, function returns name output map. map stored GRASS GIS location/mapset, might retrieved R rgrass7::read_RAST() function exported outside GRASS using r..gdal module, instance.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi_cumulative.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the cumulative zone of influence of multiple features — calc_zoi_cumulative","text":"","code":"calc_zoi_cumulative(   x,   radius = 100,   type = c(\"circle\", \"Gauss\", \"rectangle\", \"exp_decay\", \"bartlett\", \"threshold\",     \"mfilter\")[1],   where = c(\"R\", \"GRASS\")[1],   module = c(\"r.mfilter\", \"r.resamp.filter\", \"r.neighbors\")[1],   output_type = c(\"cumulative_zoi\", \"density\")[1],   zoi_limit = 0.05,   min_intensity = 0.01,   max_dist = 50000,   zeroAsNA = FALSE,   extent_x_cut = NULL,   extent_y_cut = NULL,   na.policy = \"omit\",   na.rm = TRUE,   plotit = FALSE,   output_map_name = NULL,   input_as_region = FALSE,   remove_intermediate = TRUE,   overwrite = FALSE,   quiet = TRUE,   ... )"},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi_cumulative.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the cumulative zone of influence of multiple features — calc_zoi_cumulative","text":"x [RasterLayer,SpatRaster,character]  Raster representing locations features, preferentially binary map 1 features located (counts features within pixel) 0 elsewhere. Alternatively, x might binary (dummy) spatial variable representing presence linear area features. x can RasterLayer raster package SpatRaster terra package. = \"GRASS\", x must string corresponding name input map within GRASS GIS location mapset. Continuous discrete raster maps multiple categories can binarized used input calc_zoi_cumulative() landscapetools::util_binarize() R grass_binarize() GRASS GIS, common raster algebra environments. radius [numeric(1)=100]  Radius scale moving window neighborhood analysis, used calculate cumulative zoi density. can single value vector values, case several cumulative ZoI density maps (one radius) created. type = \"circle\", radius corresponds radius circle filter. type = \"Gauss\" type = \"exp_decay\", radius corresponds distance Gaussian exponential decay function decrease small zoi_limit value. type = \"bartlett\", radius distance filter reaches zero, linear decay central pixel. type = \"rectangle\", radius corresponds half size side square filter. type = \"mfilter\", radius numeric value matrix , defined user. See description details. type [character(1)=\"circle\"]{\"circle\", \"Gauss\", \"rectangle\", \"exp_decay\", \"bartlett\", \"threshold\", \"step\", \"mfilter\"}  Type filter used calculate cumulative ZoI density. See details. [character(1)=\"R\"]{\"R\", \"GRASS\"}  computation done? Default \"R\". = \"GRASS\", R session must linked open GRASS GIS session specific location mapset. module [character(1)=\"r.mfilter\"]{\"r.mfilter\", \"r.resamp.filter\", \"r.neighbors\"}  = \"GRASS\", algorithm used compute cumulative ZoI? See details description. output_type [character(1)=\"cumulative_zoi\"]{\"cumulative_zoi\", \"density\"}  output_type = \"cumulative_zoi\" (default), ZoI weight matrix normalized, .e. maximum value weight matrix central pixel value always 1. means values input map summed (considering decay distance within neighborhood) output map presents values higher 1. output_type = \"density\", weight matrix normalized filtering process, leading values outmap map generally lower 1. zoi_limit [numeric(1)=0.05]  non-vanishing functions (e.g. exp_decay, gaussian_decay), value used set relationship ZoI radius decay functions: radius defined minimum distance ZoI assumes values zoi_limit. default 0.05. parameter used radius NULL. min_intensity [numeric(1)=0.01]  Minimum intensity exponential Gaussian decay functions define radius window define filter. See filter_create() details. max_dist [numeric(1)=50000]  Maximum size (meters) define radius window defines filter. applicable exponential Gaussian decay functions. See filter_create() details. zeroAsNA [logical(1)=FALSE]  TRUE treats cells NA zero. extent_x_cut, entent_y_cut [numeric vector(2)=c(0,1)]  Vector representing minimum maximum extent x y final output, format c(min,max). intended keep region interest consider surroundings calculating cumulative ZoI density. might especially useful example use r.mfilter algorithm GRASS, edges region excluded computation. default keep extent input raster. na.policy [character(1)=\"omit\"] \\cr Can used determine cells xfor focal values computed. Must one \"\" (compute cells), \"\" (cells NA) \"omit\" (skip cells NA). Note value argument affect cells around focal cell included computations (use na.rm=TRUE ignore cells NA ). See [terra::focal()] details. used whenwhere = \"R\"`. na.rm [logical(1)=FALSE]  missing values removed filtering calculations? Option neighborhood analysis performed terra::focal() function. used = \"R\". plotit [logical(1)=FALSE]  outputs plotted along calculation? used = \"R\". output_map_name [character(1)=NULL]  Name output map. used = \"GRASS\". NULL (default), standard name created based name input map x, ZoI shape type, ZoI radius radius. input_as_region [logical(1)=TRUE]  input map x used redefine working GRASS region cumulative ZoI calculation? TRUE, x used define region g.region. FALSE, region previously defined GRASS GIS session used computation. remove_intermediate [logical(1)=TRUE]  intermediate maps created computing output map excluded end process? used = \"GRASS\". overwrite [logical(1)=FALSE]  map already exists name output_map_name working GRASS GIS location mapset, overwritten? used = \"GRASS\". quiet [logical(1)=TRUE]  GRASS GIS messages ommited prompt along computation? used = \"GRASS\". ... arguments used within filter_create() terra::focal().","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi_cumulative.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the cumulative zone of influence of multiple features — calc_zoi_cumulative","text":"RasterLayer SpatRaster (according input x map) cumulative zone influence density features. cumulative ZoI uses ZoI/weight matrix rescaled 1 central pixel (creating values output map might go well beyond 1), density features uses normalized ZoI/weight matrix (values summing 1), created values smaller one output map. multiple radius values given, RasterBrick multi-layer SpatRaster, cumulative ZoI density maps ZoI radius. computation done GRASS GIS, output name output raster map within GRASS GIS location mapset current session. user can retrieve maps R using rgrass7::read_RAST() export outside GRASS using r..gdal module, instance.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi_cumulative.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the cumulative zone of influence of multiple features — calc_zoi_cumulative","text":"input raster supposed represent location point, line, polygon infrastructure (e.g. houses, roads, mining areas), landscape variable whose representation might one fit (e.g. areas forest habitat type land cover). recommend input raster metric projection, distances zones influence based distance infrastructure measured meters.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi_cumulative.html","id":"zone-of-influence-functions-and-weight-matrices","dir":"Reference","previous_headings":"","what":"Zone of Influence functions and weight matrices","title":"Calculate the cumulative zone of influence of multiple features — calc_zoi_cumulative","text":"neighborhood analysis define cumulative ZoI can computed different functions/filters. options currently implemented : circular/threshold matrix: circular filter (type = \"circle\" type = \"threshold\" type = \"step\") matrix constant weights parameter radius corresponds radius circle centered central pixel. similar circular buffer matrix. Gaussian matrix: Gaussian filter (type = \"Gauss\" type = \"gauss\" type = \"gaussian_decay\") matrix weights following Gaussian Normal decay. Gaussian curve 1 central cell parameterized radius zoi_limit, controls fast curve decreases distance. See zoi_functions() details. Exponential decay matrix: exponential decay filter (type = \"exp_decay\") matrix weights following exponential decay curve, value 1 central cell parameterized radius zoi_limit. See zoi_functions() details. Rectangular matrix: rectangular filter (type = \"rectangle\" type = \"box\") weight matrix whose shape square dimensions \\(n\\) x \\(n\\), \\(n = 2 * radius\\). Bartlett linear decay matrix: Bartlett, linear, tent decay filter (type = \"bartlett\" type = \"linear_decay\" type = \"tent_decay\") weight matrix whose value 1 central cell whose weights decrease linearly zero distance equals radius. See zoi_functions() details. user-customized filter: type = \"mfilter\", radius numeric user-defined matrix weights. Examples ones created filter_create(), terra::focalMat(), smoothie::kernel2dmeitsjer(), matrices created hand. Weight matrices might differ expected decay function depending intended resolution - finer resolution, detailed correspondent original functions matrix .","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi_cumulative.html","id":"algorithms-in-grass-gis","dir":"Reference","previous_headings":"","what":"Algorithms in GRASS GIS","title":"Calculate the cumulative zone of influence of multiple features — calc_zoi_cumulative","text":"GRASS GIS, different modules might used computation, r.resamp.filter, r.mfilter, r.neighbors. module used controlled parameter module. algorithms provide different capabilities flexibility. r.resamp.filter seems fastest one cases, less flexibility choice zone influence function. algorithm calculates weighted density features, might rescaled cumulative ZoI appropriate scaling factor (calculated weight matrix) provided. Currently filters type = \"bartlett\" type = \"box\" implemented. information algorithm . r.mfilter slower r.resamp.filter much faster r.neighbors, allow flexible choice shape zone influence (wight matrix shape). r.mfilter indicated terms balance flexibility choice ZoI shape computation efficiency. inconvenient r.mfilter creates edge effect information outer cells raster (number cells correspond radius half size weight matrix), used users add buffer area \\(ge radius\\) around input raster map, avoid edge effects. See https://github.com/OSGeo/grass/issues/2184 details. r.neighbors considerably slower algorithms (10 100 times), allow flexible choice ZoI shape. Contrary r.resamp.filter r.mfilter, can perform sum pixel values weighted input filter ZoI, r.neighbors might calculate many statistical summaries within window analysis, mean, median, standard deviation etc.","code":""},{"path":[]},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi_cumulative.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the cumulative zone of influence of multiple features — calc_zoi_cumulative","text":"","code":"# Running calc_zoi_cumulative through R library(terra)  # Load raster data f <- system.file(\"raster/cabins_count.tif\", package = \"oneimpact\") cabins <- terra::rast(f)  # calculate cumulative zone of influence for multiple influence radii, # using a Gaussian filter zoi_values <- c(250, 500, 1000, 2500, 5000) cumzoi_gauss <- calc_zoi_cumulative(cabins, type = \"Gauss\", radius = zoi_values) plot(cumzoi_gauss)   # calculate cumulative zone of influence for multiple influence radii, # using a circle neighborhood cumzoi_circle <- calc_zoi_cumulative(cabins, type = \"circle\", radius = zoi_values) plot(cumzoi_circle)   # calculate cumulative zone of influence for multiple influence radii, # using an exponential decay neighborhood cumzoi_exp <- calc_zoi_cumulative(cabins, type = \"exp_decay\", radius = zoi_values) plot(cumzoi_exp)   # comparing plot(c(cumzoi_gauss[[3]], cumzoi_circle[[3]], cumzoi_exp[[3]]),      main = c(\"Gaussian 1000m\",               \"Circle 1000m\",               \"Exponential decay 1000m\"))   # calculate cumulative influence for a single zone of influence # using a user-defined filter my_filter <- filter_create(cabins, radius = 1000, type = \"rectangle\") cumzoi_user <- calc_zoi_cumulative(cabins, type = \"mfilter\", radius = my_filter) plot(cumzoi_user, main = \"User-defined rectangular filter\")   # calculate density with 1000m radius using an exp_decay neighborhood density_exp <- calc_zoi_cumulative(cabins, type = \"exp_decay\", radius = 1000,                                    output_type = \"density\") # compare # note the difference in the color scales plot(c(cumzoi_exp[[3]], density_exp),      main = c(\"Cumulative ZoI 1000m\", \"Density 1000m\"))   #-------------------- # Running calc_zoi_cumulative through GRASS GIS library(rgrass7) #> Loading required package: XML #> GRASS GIS interface loaded with GRASS version: (GRASS not running) library(terra)  # Load raster data f <- system.file(\"raster/cabins.tif\", package = \"oneimpact\") cabins <- terra::rast(f)  # connect to grass gis 7.8 and create grass location # For linux or within OSGeo4W shell grassdir <- system(\"grass78 --config path\", intern = TRUE) # If you used the standalone installer in Windows # grassdir <- \"C:\\Programs\\GRASS GIS 7.8\" # Correct if the path is different  gisDB <- \".\" # create location and mapset in the working directory loc <- \"ETRS_33N/\" # name of the location ms <- \"PERMANENT\" # name of the mapset rgrass7::initGRASS(gisBase = grassdir,                    SG = cabins, # use map to define location projection                    home = tempdir(),                    override = TRUE,                    gisDbase = gisDB,                    location = loc,                    mapset = ms) #> gisdbase    .  #> location    ETRS_33N/  #> mapset      PERMANENT  #> rows        361  #> columns     478  #> north       6658900  #> south       6622800  #> west        146900  #> east        194700  #> nsres       100  #> ewres       100  #> projection  +proj=utm +no_defs +zone=33 +a=6378137 +rf=298.257222101 #> +towgs84=0,0,0,0,0,0,0 +type=crs +to_meter=1   # define map name within GRASS GIS cabins_g <- \"cabins_example\" # add file to GRASS GIS mapset rgrass7::write_RAST(cabins, cabins_g, flags = c(\"o\", \"overwrite\")) #> Over-riding projection check #> Importing raster map <cabins_example>... #>    0%   3%   6%   9%  12%  15%  18%  21%  24%  27%  30%  33%  36%  39%  42%  45%  48%  51%  54%  57%  60%  63%  66%  69%  72%  75%  78%  81%  84%  87%  90%  93%  96%  99% 100% #> SpatRaster read into GRASS using r.in.gdal from file   # check terra::plot(cabins, col = \"black\",             main = \"Map of tourist cabins\")   #--- # define region in GRASS GIS rgrass7::execGRASS(\"g.region\", raster = cabins_g,                    flags = \"p\") #> projection: 99 (unknown) #> zone:       0 #> datum:      etrs89 #> ellipsoid:  grs80 #> north:      6658900 #> south:      6622800 #> west:       146900 #> east:       194700 #> nsres:      100 #> ewres:      100 #> rows:       361 #> cols:       478 #> cells:      172558  #--- # Guarantee input map is binary (zeros as background)  # Input map name within GRASS GIS - binary map cabins_bin_g <- grass_binarize(cabins_g, breaks = 1, output = \"cabins_example_bin\",                                null = 0, overwrite = TRUE) #> Removing raster <inter_map>  # check input cabins_bin <- rgrass7::read_RAST(\"cabins_example_bin\", return_format = \"terra\", NODATA = 255) #> Checking GDAL data type and nodata value... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> Using GDAL data type <Byte> #> Exporting raster data to RRASTER format... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> r.out.gdal complete. File <\/tmp/RtmpXPIaXj/file5194656f29cb.grd> created.  plot(cabins_bin, col = c(\"lightyellow\", \"black\"),      main = \"Binarized map of cabins\")   #--- # Using 'r.mfilter' algorithm (default)  # Exponential decay exp_name <- calc_zoi_cumulative(x = cabins_bin_g,                                 radius = 1000, zoi_limit = 0.01,                                 type = \"exp_decay\",                                 where = \"GRASS\",                                 overwrite = TRUE, quiet = FALSE) #> [1] \"Calculating cumulative ZoI for 1000, shape exp_decay...\" #>    0%   3%   6%   9%  12%  15%  18%  21%  24%  27%  30%  33%  36%  39%  42%  45%  48%  51%  54%  57%  60%  63%  66%  69%  72%  75%  78%  81%  84%  87%  90%  93%  96%  99% 100% #> Writing raster map <cabins_example_bin_zoi_cumulative_exp_decay1000> # Bartlett decay barlett_name <- calc_zoi_cumulative(x = cabins_bin_g, radius = 1000,                                     type = \"bartlett\",                                     where = \"GRASS\",                                     overwrite = TRUE, quiet = FALSE) #> [1] \"Calculating cumulative ZoI for 1000, shape bartlett...\" #>    0%   3%   6%   9%  12%  15%  18%  21%  24%  27%  30%  33%  36%  39%  42%  45%  48%  51%  54%  57%  60%  63%  66%  69%  72%  75%  78%  81%  84%  87%  90%  93%  96%  99% 100% #> Writing raster map <cabins_example_bin_zoi_cumulative_bartlett1000> # Gaussian decay gauss_name <- calc_zoi_cumulative(x = cabins_bin_g,                                   radius = 1000, zoi_limit = 0.01,                                   type = \"Gauss\",                                   where = \"GRASS\",                                   overwrite = TRUE, quiet = FALSE) #> [1] \"Calculating cumulative ZoI for 1000, shape Gauss...\" #>    0%   3%   6%   9%  12%  15%  18%  21%  24%  27%  30%  33%  36%  39%  42%  45%  48%  51%  54%  57%  60%  63%  66%  69%  72%  75%  78%  81%  84%  87%  90%  93%  96%  99% 100% #> Writing raster map <cabins_example_bin_zoi_cumulative_Gauss1000>  # Threshold decay (circle, step) threshold_name <- calc_zoi_cumulative(x = cabins_bin_g, radius = 1000,                                       type = \"threshold\",                                       where = \"GRASS\",                                       overwrite = TRUE, quiet = FALSE) #> [1] \"Calculating cumulative ZoI for 1000, shape threshold...\" #>    0%   3%   6%   9%  12%  15%  18%  21%  24%  27%  30%  33%  36%  39%  42%  45%  48%  51%  54%  57%  60%  63%  66%  69%  72%  75%  78%  81%  84%  87%  90%  93%  96%  99% 100% #> Writing raster map <cabins_example_bin_zoi_cumulative_threshold1000>  (all_names <- c(exp_name, barlett_name, gauss_name, threshold_name)) #> [1] \"cabins_example_bin_zoi_cumulative_exp_decay1000\" #> [2] \"cabins_example_bin_zoi_cumulative_bartlett1000\"  #> [3] \"cabins_example_bin_zoi_cumulative_Gauss1000\"     #> [4] \"cabins_example_bin_zoi_cumulative_threshold1000\"  # visualize cabins_zoi_cumulative <- rgrass7::read_RAST(all_names, return_format = \"terra\") #> Checking GDAL data type and nodata value... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> Using GDAL data type <Float32> #> Exporting raster data to RRASTER format... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> r.out.gdal complete. File <\/tmp/RtmpXPIaXj/file51943c8a6220.grd> created. #> Checking GDAL data type and nodata value... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> Using GDAL data type <Float32> #> Exporting raster data to RRASTER format... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> r.out.gdal complete. File <\/tmp/RtmpXPIaXj/file51941c498448.grd> created. #> Checking GDAL data type and nodata value... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> Using GDAL data type <Float32> #> Exporting raster data to RRASTER format... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> r.out.gdal complete. File <\/tmp/RtmpXPIaXj/file51946627f744.grd> created. #> Checking GDAL data type and nodata value... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> Using GDAL data type <Float32> #> Exporting raster data to RRASTER format... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> r.out.gdal complete. File <\/tmp/RtmpXPIaXj/file519417f98a4c.grd> created.  title_plot <- c(\"Exponential decay 1000m\", \"Bartlett decay 1000m\",                 \"Gaussian decay 1000m\", \"Threshold decay 1000m\") terra::plot(cabins_zoi_cumulative, main = title_plot)   #--- # calculate density vs cumulative ZoI exp_name_d <- calc_zoi_cumulative(x = cabins_bin_g,                                   radius = 1000, zoi_limit = 0.01,                                   type = \"exp_decay\", output_type = \"density\",                                   where = \"GRASS\",                                   overwrite = TRUE, quiet = FALSE) #> [1] \"Calculating density for 1000, shape exp_decay...\" #>    0%   3%   6%   9%  12%  15%  18%  21%  24%  27%  30%  33%  36%  39%  42%  45%  48%  51%  54%  57%  60%  63%  66%  69%  72%  75%  78%  81%  84%  87%  90%  93%  96%  99% 100% #> Writing raster map <cabins_example_bin_density_exp_decay1000>  cabins_density <- rgrass7::read_RAST(exp_name_d, return_format = \"terra\") #> Checking GDAL data type and nodata value... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> Using GDAL data type <Float32> #> Exporting raster data to RRASTER format... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> r.out.gdal complete. File <\/tmp/RtmpXPIaXj/file5194b9b4a1c.grd> created.  terra::plot(c(cabins_zoi_cumulative[[1]], cabins_density),             main = c(\"Cumulative ZoI\", \"Density\"))   #--- # Using 'r.resamp.filter' algorithm  # rectangle rectangle_resamp_filt <- calc_zoi_cumulative(x = cabins_bin_g,                                              radius = 1000,                                              type = \"box\",                                              output_type = \"density\",                                              where = \"GRASS\",                                              module = \"r.resamp.filter\",                                              overwrite = TRUE, quiet = FALSE) #> [1] \"Calculating density for 1000, shape box...\" #>    0%   3%   6%   9%  12%  15%  18%  21%  24%  27%  30%  33%  36%  39%  42%  45%  48%  51%  54%  57%  60%  63%  66%  69%  72%  75%  78%  81%  84%  87%  90%  93%  96%  99% 100% rgrass7::read_RAST(rectangle_resamp_filt, return_format = \"terra\") |>   plot(main = \"Rectangle ZoI 1000m\") #> Checking GDAL data type and nodata value... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> Using GDAL data type <Float64> #> Exporting raster data to RRASTER format... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> r.out.gdal complete. File <\/tmp/RtmpXPIaXj/file519419245afa.grd> created.   # bartlett bartlett_resamp_filt <- calc_zoi_cumulative(x = cabins_bin_g,                                             radius = 1000,                                             type = \"bartlett\",                                             output_type = \"cumulative_zoi\",                                             where = \"GRASS\",                                             module = \"r.resamp.filter\",                                             overwrite = TRUE, quiet = FALSE) #> [1] \"Calculating cumulative ZoI for 1000, shape bartlett...\" #>    0%   3%   6%   9%  12%  15%  18%  21%  24%  27%  30%  33%  36%  39%  42%  45%  48%  51%  54%  57%  60%  63%  66%  69%  72%  75%  78%  81%  84%  87%  90%  93%  96%  99% 100% #> [1] \"Rescaling from density to cumulative ZoI...\" #> [1] \"cabins_example_bin_zoi_cumulative_bartlett1000 = cabins_example_bin_zoi_cumulative_bartlett1000_temp/0.0095562598354124\" #> Removing raster <cabins_example_bin_zoi_cumulative_bartlett1000_temp> rgrass7::read_RAST(bartlett_resamp_filt, return_format = \"terra\") |>   plot(main = \"Bartlett ZoI 1000m\") #> Checking GDAL data type and nodata value... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> Using GDAL data type <Float64> #> Exporting raster data to RRASTER format... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> r.out.gdal complete. File <\/tmp/RtmpXPIaXj/file519412994004.grd> created.   # Gaussian - to be implemented! if(FALSE) {   gauss_resamp_filt <- calc_zoi_cumulative(x = cabins_bin_g,                                            radius = \"1000,3000\",                                            type = \"gauss,box\",                                            output_type = \"cumulative_zoi\",                                            where = \"GRASS\",                                            module = \"r.resamp.filter\",                                            overwrite = TRUE, quiet = FALSE)   rgrass7::read_RAST(bartlett_resamp_filt, return_format = \"terra\") |>     plot() }  # remove rasters created to_remove_rast <- unique(c(all_names, exp_name_d,                            rectangle_resamp_filt, bartlett_resamp_filt)) # rgrass7::execGRASS(\"g.remove\", type = \"vect\", name = to_remove_vect, flags = \"f\") # rgrass7::execGRASS(\"g.remove\", type = \"rast\", name = to_remove_rast, flags = \"f\")"},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi_nearest.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the zone of influence from the nearest feature — calc_zoi_nearest","title":"Calculate the zone of influence from the nearest feature — calc_zoi_nearest","text":"function takes raster locations counts infrastructure calculates raster (set rasters, case one value radius) representing zone influence (ZoI) neareast feature type infrastructure. Zones influence defined functions decay distance infrastructure rate decay controlled ZoI radius (radius), defines far influence infrastructure feature goes. default, Gaussian decay ZoI calculated, decay shapes might used (see zoi_functions() examples). function might also return distance nearest feature transformation (e.g. log- sqrt-distance nearest feature). procedure might computed R GRASS GIS. GRASS, requires active connection R session GRASS GIS location mapset (package rgrass7), input maps already loaded within GRASS GIS mapset. calculations done R, input (set ) raster map(s) function returns another (set ) raster map(s). calculations done within GRASS GIS, input name raster map already loaded GRASS GIS location mapset, function returns name output map. map stored GRASS GIS location/mapset, might retrieved R rgrass7::read_RAST() function exported outside GRASS using r..gdal module, instance.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi_nearest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the zone of influence from the nearest feature — calc_zoi_nearest","text":"","code":"calc_zoi_nearest(   x,   radius = NULL,   type = c(\"Gauss\", \"exp_decay\", \"bartlett\", \"half_norm\", \"threshold\", \"step\",     \"euclidean\", \"log\", \"sqrt\")[1],   where = c(\"R\", \"GRASS\")[1],   intercept = 1,   zoi_limit = 0.05,   lambda = NULL,   log_base = exp(1),   dist_offset = 0,   zeroAsNA = FALSE,   extent_x_cut = NULL,   extent_y_cut = NULL,   g_output_map_name = NULL,   g_dist_metric = c(\"euclidean\", \"geodesic\", \"squared\", \"maximum\", \"manhattan\")[1],   g_input_as_region = FALSE,   g_remove_intermediate = TRUE,   g_print_expression = FALSE,   g_verbose = FALSE,   g_overwrite = FALSE,   ... )"},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi_nearest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the zone of influence from the nearest feature — calc_zoi_nearest","text":"x [RasterLayer,SpatRaster]  Raster representing locations features, preferentially positive value features located NA elsewhere. Alternatively, x might binary (dummy) spatial variable representing presence linear area features, NA/-data background. x can RasterLayer raster package SpatRaster terra package. = \"GRASS\", x must string corresponding name input map within GRASS GIS location mapset. input raster x positive values pixels infrastructure located NA/-data places. R also possible zeros background set zeroAsNA = TRUE computation ZoI nearest feature. GRASS, maps without NA background might prepared input calc_zoi_nearest() raster algebra e.g. use module r.null. radius [numeric(1)]  Radius zone influence (ZoI), distance ZoI vanishes goes given minimum limit value zoi_limit. See zoi_functions() details. parameter ignored type = \"euclidean\", type = \"log\", type = \"sqrt\". type [character(1)=\"Gauss\"]{\"Gauss\", \"exp_decay\", \"bartlett\", \"threshold\", \"step\", \"euclidean\", \"log\",\"sqrt\"} Gauss half_norm, ZoI follows half-normal shape: intercept * exp(-lambda * (euclidean_distance^2)). intercept lambda parameters defined -- see zoi_functions() details. exp_decay, ZoI follows exponential decay shape: intercept * exp(-lambda * euclidean_distance). intercept lambda parameters defined -- see zoi_functions() details. bartlett, linear_decay, tent_decay, ZoI follows linear decay shape within ZoI radius (radius). threshold step, constant influence considered within zone influence radius (radius). pixels closer radius infrastructure considered \"influence\" nearest feature, constant influence value defined intercept parameter, pixels assumed zero influence. euclidean, function returns Euclidean distance proxy ZoI, even though proper zone influence defined case. log, function returns log-distance: log(euclidean_distance, base = log_base) proxy ZoI, even though proper zone influence defined case. sqrt, functions returns square rooted distance: sqrt(euclidean_distance) proxy ZoI, even though proper zone influence defined case. See details . options still implemented (functions generic user-defined ZoI function input). [character(1)=\"R\"]{\"R\", \"GRASS\"}  computation done? Default \"R\". = \"GRASS\", R session must linked open GRASS GIS session specific location mapset. intercept [numeric(1)=1]  Maximum value ZoI functions distance disturbance sources zero (x = 0). threshold_decay step_decay functions, intercept constant value Zone Influence within ZoI radius. ZoI functions, intercept value functions origin (sources disturbance located, .e. x = 0). Default intercept = 1. parameter ignored type = \"euclidean\", type = \"log\", type = \"sqrt\". zoi_limit [numeric(1)=0.05]  non-vanishing functions (e.g. exp_decay, gaussian_decay), value used set relationship ZoI radius decay functions: radius defined minimum distance ZoI assumes values zoi_limit. default 0.05. parameter used radius NULL. lambda [numeric(2)=NULL]  Gaussian exponential decay functions (type = \"Gauss\" type = \"exp_decay\"), lambda decay parameter function. Notice interpretation lambda different depending function -- see zoi_functions() definitions. Gaussian decay function, value lambda considered radius = NULL sigma = NULL. exponential decay function, value lambda considered radius = NULL half_life = NULL. log_base [numeric(1)=exp(1)]  Base logarithm, type = log. dist_offset [numeric(1)=0]  Number add Euclidean distance transforming , avoid -Inf/Inf values (e.g. case log transformation). small value compared range values Euclidean distance, influence analyses. zeroAsNA [logical(1)=FALSE]  TRUE treats cells zero NA. used computations R (= R). extent_x_cut, entent_y_cut [numeric vector(2)=NULL]  Vector representing minimum maximum extent x y final output, format c(min,max). intended keep region interest, standardizing parameters region comparing resulting ZoI maps cumulative ZoI, calculated calc_zoi_cumulative(). NULL (default), parameter ignored. g_output_map_name [character(1)=NULL]  Name output map name, used within GRASS (= \"GRASS\"). default, NULL output map names concatenation input map name (e.g. \"map_houses\") decay function radius used (e.g. type = \"exp_decay\" radius = 1000, name \"map_houses_exp_decay1000\"). parameter ignored calculations performed R (= \"R\"). g_dist_metric [character(1)=\"euclidean\"]{\"euclidean\", \"geodesic\", \"squared\", \"maximum\", \"manhattan\"}  calculations perfomed within GRASS GIS, metric argument calculate distance infrastructure features module r.grow.distance. information GRASS GIS documentation function. parameter ignored calculations performed R (= \"R\"). g_input_as_region [logical(1)=FALSE]  input map x used redefine working region GRASS ZoI calculation? TRUE, x used define region g.region. FALSE, region previously defined GRASS GIS session used computation. Default FALSE. parameter ignored calculations performed R (= \"R\"). g_remove_intermediate [logical(1)=TRUE]  intermediate maps created computing output map excluded end process? used = \"GRASS\". g_print_expression [logical(1)=FALSE]  expression transforming raster distance ZoI values printed prompt? used = \"GRASS\" g_verbose = TRUE debugging result r.mapcalc. g_verbose [logical(1)=FALSE]  GRASS GIS messages shown prompt along computation? used = \"GRASS\". g_overwrite [logical(1)=FALSE]  map already exists name g_output_map_name working GRASS GIS location mapset, overwritten? used = \"GRASS\". ... Adittional parameters passed terra::distance() ZoI functions (see zoi_functions()) calculations performed R. additional parameters implemented computation GRASS GIS.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi_nearest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the zone of influence from the nearest feature — calc_zoi_nearest","text":"calculations performed R (= \"R\"), function returns RasterLayer (SpatRaster, according class input object) zone influence nearest feature. multiple values radius provided, stack rasters returned. calculations performed GRASS GIS (= \"GRASS\"), maps kept within GRASS GIS location/mapset function returns name calculated maps. computation done GRASS GIS, output name output raster map within GRASS GIS location mapset current session. user can retrieve maps R using rgrass7::read_RAST export outside GRASS using r..gdal module, instance.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi_nearest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the zone of influence from the nearest feature — calc_zoi_nearest","text":"practice, function calc_zoi_nearest() first calculates distance pixel nearest feature transforms according ZoI functions. R, calc_zoi_nearest() makes use terra::distance() function following procedures made raster algebra. GRASS, module r.grow.distance used calculate Euclidean distance nearest feature r.mapcalc.simple transform distance different ZoI nearest feature. input raster x positive values pixels infrastructure located NA/-data places. input raster supposed represent location point, line, polygon infrastructure (e.g. houses, roads, mining areas), landscape variable whose representation might one fit (e.g. areas forest habitat type land cover). recommend input raster metric projection, distances zones influence based distance infrastructure measured meters.","code":""},{"path":[]},{"path":"https://ninanor.github.io/oneimpact/reference/calc_zoi_nearest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the zone of influence from the nearest feature — calc_zoi_nearest","text":"","code":"# Running calc_zoi_nearest through R library(mobsim) #>  #> Attaching package: ‘mobsim’ #> The following object is masked from ‘package:oneimpact’: #>  #>     dist_decay library(terra) library(sf) #> Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1; sf_use_s2() is TRUE  set.seed(1234)  # set points ext <- 30000 wd <- ext/20 pts <- set_points(n_features = 50, centers = 1,                   width = wd, res = 100,                   extent_x = c(0, ext), extent_y = c(0, ext)) plot(pts$pts)  plot(pts$rast)   # calculate distance to the nearest feature d <- calc_zoi_nearest(pts$rast, type = \"euclidean\") plot(d)   # calculate log_dist (the rest is equal) log_d <- calc_zoi_nearest(pts$rast, type = \"log\", log_base = 10) plot(log_d)   # calculate sqrt_dist sqrt_d <- calc_zoi_nearest(pts$rast, type = \"sqrt\") plot(sqrt_d)   # calculate exponential decay zone of influence # using exp_decay_parms parameter exp_d1 <- calc_zoi_nearest(pts$rast, type = \"exp_decay\",                            intercept = 1, lambda = 0.001) plot(exp_d1)   # calculate exponential decay zone of influence using # radius and zoi_limit (default) radius2 <- 1000 # zoi = 1000m zoi_limit2 <- 0.05 # here zoi is the distance where the function reaches 0.05 exp_d2 <- calc_zoi_nearest(pts$rast, type = \"exp_decay\", radius = radius2,                            zoi_limit = zoi_limit2) plot(exp_d2) # buffer pts_shp <- pts$pts |>   sf::st_as_sf(coords = c(1,2)) # zoi = 1000m pts_shp |>   sf::st_buffer(dist = radius2) |>   sf::st_union() |>   plot(add = T, border = \"black\") legend(\"bottomright\", legend = c(\"ZoI radius\"), col = c(\"black\"), lwd = 1.1)   # calculate exponential decay zone of influence using half life parameter # if half_life = 250 m and zoi_hl_ratio = 4, zoi is 1000 m half_life3 <- 250 # intensity gets down to 1/16 = 0.06 for 4*half_life=1000m zoi_hl_ratio3 <- 4 # default exp_d4 <- calc_zoi_nearest(pts$rast, type = \"exp_decay\", half_life = half_life3,                            zoi_hl_ratio = zoi_hl_ratio3) plot(exp_d4) # buffer pts_shp <- pts$pts |>   sf::st_as_sf(coords = c(1,2)) # half_life = 250m pts_shp |>   sf::st_buffer(dist = half_life3) |>   sf::st_union() |>   plot(add = T, border = \"red\") # zoi = 1000m pts_shp |>   sf::st_buffer(dist = half_life3*zoi_hl_ratio3) |>   sf::st_union() |>   plot(add = T, border = \"black\") legend(\"bottomright\", legend = c(\"Exponential half-life\", \"ZoI radius\"),        col = c(\"red\", \"black\"), lwd = 1.1)   # calculate exponential decay zone of influence using # radius parameter and zoi_hl_ratio radius4 <- 4000 # intensity gets down to 1/16 = 0.06 for zoi = 4000m, half_life = 1000m zoi_hl_ratio4 <- 6 # default exp_d4 <- calc_zoi_nearest(pts$rast, type = \"exp_decay\", radius = radius4,                            zoi_hl_ratio = zoi_hl_ratio4) plot(exp_d4) # buffer pts_shp <- pts$pts |>   sf::st_as_sf(coords = c(1,2)) # half_life = 1000m pts_shp |>   sf::st_buffer(dist = radius4/zoi_hl_ratio4) |>   sf::st_union() |>   plot(add = T, border = \"red\") # zoi = 4000m pts_shp |>   sf::st_buffer(dist = radius4) |>   sf::st_union() |>   plot(add = T, border = \"black\", ) legend(\"bottomright\", legend = c(\"Exponential half-life\", \"ZoI radius\"),        col = c(\"red\", \"black\"), lwd = 1.1)   # bartlett influence, ZOI = 2000m bart_d <- calc_zoi_nearest(pts$rast, type = \"bartlett\", radius = 2000) plot(bart_d)  # buffer 2000m pts_shp |>   sf::st_buffer(dist = 2000) |>   sf::st_union() |>   plot(add = T, border = \"black\") legend(\"bottomright\", legend = c(\"Bartlett ZoI 2000m\"),        col = c(\"black\"), lwd = 1.1)   # calculate threshold influence d <- calc_zoi_nearest(pts$rast, type = \"threshold\", radius = 2000) plot(d)   # Gaussian decay influence g_d <- calc_zoi_nearest(pts$rast, type = \"Gauss\", radius = 2000) plot(g_d)  # buffer 2000m pts_shp |>   sf::st_buffer(dist = 2000) |>   sf::st_union() |>   plot(add = T, border = \"black\") legend(\"bottomright\", legend = c(\"Gaussian ZoI 2000m\"),        col = c(\"black\"), lwd = 1.1)   #-------------------- # Running calc_zoi_nearest through GRASS GIS library(rgrass7) library(terra) library(sp)  # Load raster data f <- system.file(\"raster/cabins.tif\", package = \"oneimpact\") cabins <- terra::rast(f)  # connect to grass gis 7.8 and create grass location # For linux or within OSGeo4W shell grassdir <- system(\"grass78 --config path\", intern = TRUE) # If you used the standalone installer in Windows # grassdir <- \"C:\\Programs\\GRASS GIS 7.8\" # Correct if the path is different  gisDB <- \".\" # create location and mapset in the working directory loc <- \"ETRS_33N/\" # name of the location ms <- \"PERMANENT\" # name of the mapset rgrass7::initGRASS(gisBase = grassdir,                    SG = cabins, # use map to define location projection                    home = tempdir(),                    override = TRUE,                    gisDbase = gisDB,                    location = loc,                    mapset = ms) #> gisdbase    .  #> location    ETRS_33N/  #> mapset      PERMANENT  #> rows        361  #> columns     478  #> north       6658900  #> south       6622800  #> west        146900  #> east        194700  #> nsres       100  #> ewres       100  #> projection  +proj=utm +no_defs +zone=33 +a=6378137 +rf=298.257222101 #> +towgs84=0,0,0,0,0,0,0 +type=crs +to_meter=1   # define map name within GRASS GIS cabins_g <- \"cabins_example\" # add file to GRASS GIS mapset rgrass7::write_RAST(cabins, cabins_g, flags = c(\"overwrite\", \"o\")) #> Warning: The command: #> r.in.gdal --overwrite -o input=/home/runner/work/_temp/Library/oneimpact/raster/cabins.tif output=cabins_example #> produced at least one warning during execution: #> WARNING: Raster map <cabins_example> already exists and will be overwritten #> Over-riding projection check #> Importing raster map <cabins_example>... #>    0%   3%   6%   9%  12%  15%  18%  21%  24%  27%  30%  33%  36%  39%  42%  45%  48%  51%  54%  57%  60%  63%  66%  69%  72%  75%  78%  81%  84%  87%  90%  93%  96%  99% 100% #> WARNING: Raster map <cabins_example> already exists and will be overwritten #> Over-riding projection check #> Importing raster map <cabins_example>... #>    0%   3%   6%   9%  12%  15%  18%  21%  24%  27%  30%  33%  36%  39%  42%  45%  48%  51%  54%  57%  60%  63%  66%  69%  72%  75%  78%  81%  84%  87%  90%  93%  96%  99% 100% #> SpatRaster read into GRASS using r.in.gdal from file   # check terra::plot(cabins, col = \"black\",             main = \"Map of tourist cabins\")   #--- # define region in GRASS GIS rgrass7::execGRASS(\"g.region\", raster = cabins_g,                    flags = \"p\") #> projection: 99 (unknown) #> zone:       0 #> datum:      etrs89 #> ellipsoid:  grs80 #> north:      6658900 #> south:      6622800 #> west:       146900 #> east:       194700 #> nsres:      100 #> ewres:      100 #> rows:       361 #> cols:       478 #> cells:      172558  # Input map name within GRASS GIS cabins_g #> [1] \"cabins_example\"  # Exponential decay ZoI=1000m expdecay_name <- calc_zoi_nearest(cabins_g, type = \"exp_decay\",                                   radius = 1000,                                   where = \"GRASS\",                                   g_verbose = FALSE, g_overwrite = TRUE) #> Removing raster <cabins_example_zoi_nearest_euclidean>  # Bartlett decay ZoI=1000m bartlett_name <- calc_zoi_nearest(cabins_g, type = \"bartlett\",                                   radius = 1000,                                   where = \"GRASS\", g_verbose = FALSE, g_overwrite = TRUE) #> Removing raster <cabins_example_zoi_nearest_euclidean>  # Threshold influence ZoI = 1000m threshold_name <- calc_zoi_nearest(cabins_g, type = \"threshold\",                                    radius = 1000,                                    where = \"GRASS\", g_verbose = FALSE, g_overwrite = TRUE) #> Removing raster <cabins_example_zoi_nearest_euclidean>  # Gaussian influence ZoI = 1000m gaussian_name <- calc_zoi_nearest(cabins_g, type = \"Gauss\",                                   radius = 1000,                                   where = \"GRASS\", g_verbose = FALSE, g_overwrite = TRUE) #> Removing raster <cabins_example_zoi_nearest_euclidean>  # Log-distance log_name <- calc_zoi_nearest(cabins_g, type = \"log\", log_base = 10,                              where = \"GRASS\",                              g_verbose = FALSE, g_overwrite = TRUE) #> Removing raster <cabins_example_zoi_nearest_euclidean>  # Euclidean euclidean_name <- calc_zoi_nearest(cabins_g, type = \"euclidean\",                                    where = \"GRASS\",                                    g_verbose = FALSE, g_overwrite = TRUE)  (all_names <- c(euclidean_name, log_name, expdecay_name,                 bartlett_name, threshold_name, gaussian_name)) #> [1] \"cabins_example_zoi_nearest_euclidean\"     #> [2] \"cabins_example_zoi_nearest_log\"           #> [3] \"cabins_example_zoi_nearest_exp_decay1000\" #> [4] \"cabins_example_zoi_nearest_bartlett1000\"  #> [5] \"cabins_example_zoi_nearest_threshold1000\" #> [6] \"cabins_example_zoi_nearest_Gauss1000\"      # visualize cabins_zoi_nearest <- rgrass7::read_RAST(all_names, return_format = \"terra\") #> Checking GDAL data type and nodata value... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> Using GDAL data type <Float64> #> Exporting raster data to RRASTER format... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> r.out.gdal complete. File <\/tmp/RtmpXPIaXj/file519429c3e6bd.grd> created. #> Checking GDAL data type and nodata value... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> Using GDAL data type <Float64> #> Exporting raster data to RRASTER format... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> r.out.gdal complete. File <\/tmp/RtmpXPIaXj/file519468eedab1.grd> created. #> Checking GDAL data type and nodata value... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> Using GDAL data type <Float64> #> Exporting raster data to RRASTER format... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> r.out.gdal complete. File <\/tmp/RtmpXPIaXj/file519421600732.grd> created. #> Checking GDAL data type and nodata value... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> Using GDAL data type <Float64> #> Exporting raster data to RRASTER format... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> r.out.gdal complete. File <\/tmp/RtmpXPIaXj/file51947eac7800.grd> created. #> Checking GDAL data type and nodata value... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> Using GDAL data type <Float64> #> Exporting raster data to RRASTER format... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> r.out.gdal complete. File <\/tmp/RtmpXPIaXj/file519429ced4c3.grd> created. #> Checking GDAL data type and nodata value... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> Using GDAL data type <Float64> #> Exporting raster data to RRASTER format... #>    2%   5%   8%  11%  14%  17%  20%  23%  26%  29%  32%  35%  38%  41%  44%  47%  50%  53%  56%  59%  62%  65%  68%  71%  74%  77%  80%  83%  86%  89%  92%  95%  98% 100% #> r.out.gdal complete. File <\/tmp/RtmpXPIaXj/file519412b3e09c.grd> created.  title_plot <- c(\"Euclidean distance\", \"Log distance (base 10)\",                 \"Exponential ZoI 1000m\", \"Bartlett ZoI 1000m\",                 \"Threshold ZoI 1000m\", \"Gaussian ZoI 1000m\") terra::plot(cabins_zoi_nearest, main = title_plot)   # remove rasters created to_remove_rast <- c(all_names) rgrass7::execGRASS(\"g.remove\", type = \"rast\", name = to_remove_rast, flags = \"f\") #> Removing raster <cabins_example_zoi_nearest_Gauss1000> #> Removing raster <cabins_example_zoi_nearest_bartlett1000> #> Removing raster <cabins_example_zoi_nearest_euclidean> #> Removing raster <cabins_example_zoi_nearest_exp_decay1000> #> Removing raster <cabins_example_zoi_nearest_log> #> Removing raster <cabins_example_zoi_nearest_threshold1000>"},{"path":"https://ninanor.github.io/oneimpact/reference/filter_create.html","id":null,"dir":"Reference","previous_headings":"","what":"Create filters or kernel matrices for raster neighborhood analyses — filter_create","title":"Create filters or kernel matrices for raster neighborhood analyses — filter_create","text":"function creates matrices weights following different functions used neighborhood analyses rasters. context cumulative impact analysis, represent Zone Influence (ZoI) infrastructure point/pixel, used calculate cumulative ZoI. possible export matrices text files, use external software r.mfilter module within GRASS GIS.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/filter_create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create filters or kernel matrices for raster neighborhood analyses — filter_create","text":"","code":"filter_create(   r = 100,   radius = NULL,   type = c(\"exp_decay\", \"bartlett\", \"circle\", \"threshold_decay\", \"gaussian_decay\",     \"Gauss\", \"rectangle\")[1],   zoi_limit = 0.05,   half_life = NULL,   zoi_hl_ratio = NULL,   sigma = NULL,   min_intensity = 0.01,   max_dist = 5000,   normalize = FALSE,   divisor = 1,   round_vals = NULL,   save_txt = FALSE,   save_format = c(\"GRASS_rmfilter\", \"raw\")[1],   save_folder = NULL,   save_file = NULL,   parallel = TRUE )"},{"path":"https://ninanor.github.io/oneimpact/reference/filter_create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create filters or kernel matrices for raster neighborhood analyses — filter_create","text":"r [numeric,SpatRaster,RasterLayer]  Either numeric value corresponding resolution (pixel size) pixel filter matrix correspond ; raster object (SpatRaster terra package RasterLayer, RasterBrick, RasterStack raster package) resolution can extracted. radius [numeric(1)=NULL]  Zone Influence (ZoI) radius, map units (preferentially meters). ZoI radius distance, scale, buffer size around feature consider effect influence infrastructure variable. filter_create, interpretation radius differ depending shape zoi (parameter type): circle neighborhood (type = \"circle\" type = \"threshold\" type = \"step\"), radius corresponds radius (threshold) circle, beyond filter zero. rectangular neighborhood (type = \"rectangle\" type = \"box\"), radius corresponds half size square size, square size = 2*radius. rectangular filter different size sides, use terra::focal() (please note interpretation parameters different). Bartlett neighborhood (type = \"bartlett\" type = \"linear_decay\" type = \"tent_decay\"), radius corresponds distance beyond filter zero. exponential decay neighborhood (type = \"exp_decay\") Gaussian decay neighborhood (type = \"Gauss\" type = \"gaussian_decay\"), radius corresponds distance exponential decay function goes given limit distance defined zoi_limit. See zoi_functions() details. radius = NULL, exponential gaussian decay matrices defined based parameters -- see . option raise error types filters. type [character(1)=\"exp_decay\"]{\"exp_decay\", \"bartlett\", \"circle\", \"threshold_decay\", \"gaussian_decay\", \"Gauss\", \"rectangle\"}  Shape Zone Influence weight matrix. can : \"circle\", \"threshold\", \"threshold_decay\", \"step\" \"step_decay\" threshold decay ZoI; \"exp_decay\" exponential decay ZoI; \"Gauss\", \"gaussian\", \"gaussian_decay\" Gaussian decay ZoI; \"bartlett\", \"bartlett_decay\", \"linear_decay\", \"tent_decay\" linear decay ZoI; \"rectangle\" \"box\" rectangular ZoI. might correspondence weight matrix type filter_create similar functions (e.g. type = \"rectangle\" type = \"boxcar\" smoothie::kernel2dmeitsjer() type = \"Gauss\" terra::focalMat() parameter type = \"gauss\" n smoothie::kernel2dmeitsjer); however, interpretation parameters used define matrices different functions. zoi_limit [numeric(1)=0.05]  non-vanishing filters (e.g. exp_decay, gaussian_decay), value used set relationship ZoI radius decay functions: radius defined minimum distance x ZoI assumes values zoi_limit. default 0.05. parameter used radius NULL. half_life [numeric(1)=NULL]  Half life exponential decay function, meters. definition, half life distance exponential decay function reaches 0.5 maximum value. exp_decay function, ZoI radius parameter null (radius = NULL), value exponential half life (half_life = log(2)/lambda) can used parameterize exponential decay function. See details zoi_functions(). zoi_hl_ratio [numeric(1)=6]  exp_decay function, ZoI radius radius zoi_hl_ratio given half_life NULL, value used set ZoI radius (zoi_limit ignored). zoi_hl_ratio ratio ZoI radius value half life exponential function. instance, radius = 1200 zoi_hl_ratio = 6, means half_life 200. consequence, exponential decay ZoI function decreases 0.5 distance 200, ZoI radius = 1200 defined distance ZoI decreases 0.5**6 = 0.015625. sigma [numeric(1)=NULL]  Standard deviation Gaussian function. related Gaussian decay rate \\(\\lambda\\) lambda = 1/(2*sigma^2). considered compute ZoI gaussian_decay function ZoI radius parameter null (radius = NULL). min_intensity [numeric(1)=0.01]  Minimum intensity exponential Gaussian decay functions define radius window define filter. max_dist [numeric(1)=50000]  Maximum size (meters) define radius window defines filter. applicable exponential Gaussian decay functions. normalize [logical(1)=FALSE]  Whether matrix normalized (sum cells 1 normalize = TRUE) kept (default, normalize = FALSE). divisor [numeric(1)=1]  default, 1. divisor neighborhood matrix used within r.mfilter. According module documentation, \"filter process produces new category value cell input raster map layer multiplying category values cells n x n neighborhood around center cell corresponding matrix value adding together. divisor specified, sum divided divisor.\"  divisor zero, \"divisor computed cell sum MATRIX values corresponding input cell non-null.\" words, output map rescaled interval $0,1$. normalize = TRUE, divisor set n*n. round_vals [numeric(1)=NULL]  Number digits rounding weights output matrix. NULL (default), weights rounded. save_txt [logical(1)=FALSE]  ZoI matrix saved external text file? FALSE (default), output matrix just printed within R session. save_format [character(1)=\"GRASS_rmfilter\"]{\"GRASS_rmfilter\", \"raw\"}  Format function saved. Currently, either two options: GRASS GIS format module r.mfilter (save_format = \"GRASS_rmfilter\"), see details ); raw matrix (save_format = \"raw\"), values matrix printed. save_folder [character(1)=NULL]  Path folder matrix file written. NULL, current working directory used. save_file [character(1)=NULL]  Name output file, generally \".txt\" file. NULL, standard filename created, using type radius. E.g. \"filter_bartlett2000.txt\". parallel [logical(1)=TRUE]  Whether computation paralelized (details documentation r.mfilter module). separator [character(1)=\" \"]  Separator values matrix, within line. Default space.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/filter_create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create filters or kernel matrices for raster neighborhood analyses — filter_create","text":"matrix weight values. context cumulative impact assessment, call zone influence (ZoI) matrix used compute cumulative zone influence. save_txt = TRUE, matrix saved output text file, e.g. used external software.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/filter_create.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create filters or kernel matrices for raster neighborhood analyses — filter_create","text":"function creates \\(n\\) x \\(n\\) ZoI weight matrices based functions different shapes parameterized ZoI radius, \\(n\\) dimension matrix. functions (e.g. threshold decay, linear decay), size matrix defined ZoI radius, meters, given intended resolution (parameter r), potentially adding new lines columns value zero keep \\(n\\) odd number. non-vanishing function (e.g. exponential Gaussian decay), even though function parameterized ZoI radius size matrix can go beyond radius. case, size matrix \\(n\\) defined either minimum intensity function value (parameter min_intensity) maximum distance matrix radius (parameter min_dist, can set radius). Keeping \\(n\\) reasonable size guarantees neighborhood analysis using input weight matrices computationally feasible. Possible future implementation: compare results smoothie::kernel2dsmooth() smoothie::kernel2dmeitsjer(), maybe wrap options .","code":""},{"path":[]},{"path":"https://ninanor.github.io/oneimpact/reference/filter_create.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create filters or kernel matrices for raster neighborhood analyses — filter_create","text":"","code":"library(terra)  # load example - raster of tourist private cabins f <- system.file(\"raster/cabins.tif\", package=\"oneimpact\") r <- rast(f) # terra::ext(r)[1:2] %>% diff  # set value zero where there are no cabins r[is.na(r)] <- 0  # create exponential filter filt_exp1000 <- filter_create(r, radius = 1000,                               zoi_limit = 0.01,                               type = \"exp_decay\",                               max_dist = 5000,                               normalize = T) filt_exp3000 <- filter_create(r, radius = 3000,                               zoi_limit = 0.01,                               type = \"exp_decay\",                               max_dist = 5000,                               normalize = T) # use exponential filter neigh_r_exp1000 <- terra::focal(r, filt_exp1000, fun = \"sum\",                                 na.policy = \"omit\", na.rm = TRUE) neigh_r_exp3000 <- terra::focal(r, filt_exp3000, fun = \"sum\",                                 na.policy = \"omit\", na.rm = TRUE)  # plot plot(c(r, neigh_r_exp1000, neigh_r_exp3000),      main = c(\"original\", \"exp filter 1000m\", \"exp filter 3000m\"))   # create step filter filt_step3000 <- filter_create(r, radius = 3000, type = \"step\",                                normalize = T) # use step filter neigh_r_step3000 <- terra::focal(r, filt_step3000, fun = \"sum\",                                  na.policy = \"omit\", na.rm = TRUE)  # plot plot(c(neigh_r_exp3000, neigh_r_step3000),      main = c(\"exp filter 3000m\", \"step filter 3000m\"))  # plot(app(c(neigh_r_exp3000, neigh_r_step3000), \"diff\"))  # create bartlett (linear/tent decay) filter filt_bart3000 <- filter_create(r, radius = 3000, type = \"bartlett\",                                normalize = T) # use bartlett filter neigh_r_bart3000 <- terra::focal(r, filt_bart3000, fun = \"sum\",                                  na.policy = \"omit\", na.rm = TRUE)  # create Gaussian filter - parameterized with zoi filt_gauss3000 <- filter_create(r, radius = 3000,                                 type = \"Gauss\",                                 zoi_limit = 0.01,                                 normalize = T) # use Gaussian filter neigh_r_gauss3000 <- terra::focal(r, filt_gauss3000, fun = \"sum\",                                   na.policy = \"omit\", na.rm = TRUE)  # plot plot(c(neigh_r_exp3000, neigh_r_step3000, neigh_r_bart3000, neigh_r_gauss3000),      main = c(\"exp filter 3000m\", \"step filter 3000m\",               \"Bartlett filter 3000m\", \"Gaussian filter 3000m\"))  # plot(app(c(neigh_r_exp3000, neigh_r_bart3000), \"diff\")) # plot(app(c(neigh_r_step3000, neigh_r_bart3000), \"diff\"))  # Not run # save outside R for use in GRASS GIS if(FALSE) {   filter_create(r, radius = 1000,                 type = \"bartlett\",                 max_dist = 5000,                 normalize = T, save_txt = TRUE) }"},{"path":"https://ninanor.github.io/oneimpact/reference/filter_save.html","id":null,"dir":"Reference","previous_headings":"","what":"Save kernel/filter matrix to use outside R — filter_save","title":"Save kernel/filter matrix to use outside R — filter_save","text":"function saves matrix weights (filter kernel matrix) external text file. can save either raw matrix use standards running r.mfilter within GRASS GIS (specific header details).","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/filter_save.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save kernel/filter matrix to use outside R — filter_save","text":"","code":"filter_save(   filt,   radius,   type,   save_format = c(\"GRASS_rmfilter\", \"raw\")[1],   save_folder = NULL,   save_file = NULL,   divisor = 1,   normalize = FALSE,   parallel = TRUE,   separator = \" \" )"},{"path":"https://ninanor.github.io/oneimpact/reference/filter_save.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save kernel/filter matrix to use outside R — filter_save","text":"filt [matrix]  Filter weight matrix, one created filter_create() terra::focalMat(). radius [numeric(1)]  Radius Zone Influence (ZoI) matrix, meters. type [character(1)] Function kernel filter matrix (see type parameter filter_create()). save_format [character(1)=\"GRASS_rmfilter\"]{\"GRASS_rmfilter\", \"raw\"}  Format function saved. Currently, either two options: GRASS GIS format module r.mfilter (save_format = \"GRASS_rmfilter\"), see details ); raw matrix (save_format = \"raw\"), values matrix printed. save_folder [character(1)=NULL]  Path folder matrix file written. NULL, current working directory used. save_file [character(1)=NULL]  Name output file, generally \".txt\" file. NULL, standard filename created, using type radius. E.g. \"filter_bartlett2000.txt\". divisor [numeric(1)=1]  default, 1. divisor neighborhood matrix used within r.mfilter. According module documentation, \"filter process produces new category value cell input raster map layer multiplying category values cells n x n neighborhood around center cell corresponding matrix value adding together. divisor specified, sum divided divisor.\"  divisor zero, \"divisor computed cell sum MATRIX values corresponding input cell non-null.\" words, output map rescaled interval 0,1. normalize = TRUE, divisor set n*n. normalize [logical(1)=FALSE]  Whether matrix normalized (sum cells 1 normalize = TRUE) kept (default, normalize = FALSE). parallel [logical(1)=TRUE]  Whether computation paralelized (details documentation r.mfilter module). separator [character(1)=\" \"]  Separator values matrix, within line. Default space.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/filter_save.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save kernel/filter matrix to use outside R — filter_save","text":"None. funcion saves input matrix external file.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/filter_save.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Save kernel/filter matrix to use outside R — filter_save","text":"used r.mfilter GRASS GIS module, \"filter process produces new category value cell input raster map layer multiplying category values cells n x n neighborhood around center cell corresponding matrix value adding together. divisor specified, sum divided divisor.\" See details .","code":""},{"path":[]},{"path":"https://ninanor.github.io/oneimpact/reference/filter_save.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Save kernel/filter matrix to use outside R — filter_save","text":"","code":"my_filter <- filter_create(r = 100, type = \"bartlett\", radius = 1000, round = 4) filter_save(my_filter, radius = 1000, type = \"bartlett\", save_format = \"GRASS_rmfilter\") filter_save(my_filter, radius = 1000, type = \"bartlett\", save_format = \"raw\")"},{"path":"https://ninanor.github.io/oneimpact/reference/grass_binarize.html","id":null,"dir":"Reference","previous_headings":"","what":"Binarize continuous raster maps — grass_binarize","title":"Binarize continuous raster maps — grass_binarize","text":"GRASS GIS, function transforms continuous categorical maps (1 category) binary maps (two values), represent, e.g., habitat-matrix maps context landscape ecology. can also used produce binary maps form maps one category (rest NULL/-data). requires active connection R session GRASS GIS location mapset (package rgrass7), input map already loaded within GRASS GIS mapset.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/grass_binarize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binarize continuous raster maps — grass_binarize","text":"","code":"grass_binarize(   x,   breaks = 0.5,   output = paste0(x, \"_bin\"),   null = NULL,   setnull = NULL,   bin_values = c(0, 1),   input_as_region = FALSE,   quiet = TRUE,   verbose = FALSE,   overwrite = FALSE,   ... )"},{"path":"https://ninanor.github.io/oneimpact/reference/grass_binarize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Binarize continuous raster maps — grass_binarize","text":"x [character(1)]  Name input raster map, within GRASS GIS location mapset. breaks [numeric]  Breaks threshold define binary values output binary map. pixels value >= breaks considered 1 (upper value defined bin_values), rest considered 0 (lower value defined bin_values). breaks might either single numeric value vector numeric values, case multiple binary maps created (different break thresholds). output [character(1)]  Name output map, prefix output map length(breaks) > 1. latter case, names completed break value. defult use name input map, plus \"_bin\" end. null [numeric(1)=NULL]  NULL (default), NULL/-data pixels x kept output map. Otherwise, numeric value NULL pixels assume output map. uses module r.null). setnull []  NULL (default), changes made. Otherwise, set numeric values transformed NULL/NA data (using module r.null). bin_values [numeric(2)=c(0,1)]  Values c(lower, upper) output map pixels values either \"lower\" \"equal higher\" breaks. default, c(0, 1). quiet, overwrite [logical(1)]  Whether procedures GRASS GIS run quetly (flag quiet = TRUE) whether output maps overwriten (flag overwrite = TRUE).","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/grass_binarize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Binarize continuous raster maps — grass_binarize","text":"binarized map two values (set binarized maps length(breaks) > 1).","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/grass_binarize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Binarize continuous raster maps — grass_binarize","text":"similar procedure within R, use function landscapetools::util_binarize() raster algebra functions within raster terra packages.","code":""},{"path":[]},{"path":"https://ninanor.github.io/oneimpact/reference/grass_binarize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Binarize continuous raster maps — grass_binarize","text":"","code":"# libraries library(rgrass7) library(raster) library(terra) library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:raster’: #>  #>     intersect, select, union #> The following objects are masked from ‘package:terra’: #>  #>     intersect, union #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union  # connect to grass gis 7.8 grassdir <- system(\"grass78 --config path\", intern = T) gisDB <- \"/data/grass\" loc <- \"ETRS_33N/\" ms <- \"u_bb_cuminf\" rgrass7::initGRASS(gisBase = grassdir,                    home = tempdir(),                    override = T,                    gisDbase = gisDB,                    location = loc,                    mapset = ms) #> Warning: cannot create dir '/data/grass', reason 'Permission denied' #> Warning: cannot create dir '/data/grass/ETRS_33N', reason 'No such file or directory' #> Warning: cannot create dir '/data/grass/ETRS_33N//PERMANENT', reason 'No such file or directory' #> Warning: cannot create dir '/data/grass/ETRS_33N//u_bb_cuminf', reason 'No such file or directory' #> Warning: running command 'g.version' had status 1 #> Error in if (gv == \"sh: line 1: g.version: command not found\") {    compatible <- as.logical(NA)    attr(compatible, \"message\") <- gv    return(compatible)}: argument is of length zero  # input map (not binarized) rgrass7::use_sp() #> Error in rgrass7::use_sp(): sp or rgdal is not available. You need both packages installed. name_var <- \"private_cabins_sub\"  # binarize the input map  # map with only 1 cabins_bin1_name <- grass_binarize(name_var, output = \"cabins_bin1\",                                    breaks = 1, overwrite = T) #> Error in rgrass7::execGRASS(\"r.mapcalc.simple\", expression = expr, a = x,     output = out, flags = flags): The command: #> r.mapcalc.simple --quiet --overwrite expression=\"if(A >= 1.000000, 1, 0)\" a=private_cabins_sub output=cabins_bin1 #> produced an error (1) during execution: #> access: No such file or directory #> ERROR: LOCATION <\/data/grass/ETRS_33N/> not available # map with 0, 1 cabins_bin2_name <- grass_binarize(name_var, output = \"cabins_bin2\",                                    breaks = 1, null = 0, overwrite = T) #> Error in rgrass7::execGRASS(\"g.copy\", parameters = list(raster = paste0(x,     \",\", inter_map)), flags = flags): The command: #> g.copy --quiet --overwrite raster=private_cabins_sub,inter_map #> produced an error (1) during execution: #> access: No such file or directory #> ERROR: LOCATION <\/data/grass/ETRS_33N/> not available  # visualize cabins_bin1_2 <- rgrass7::readRAST(c(cabins_bin2_name, cabins_bin1_name)) %>%   raster::stack() %>%   terra::rast() #> Warning: Package rgrass7 is transitioning to package rgrass for GRASS GIS 8. #> 'readRAST' is deprecated. Use 'read_RAST' instead. #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'rast': error in evaluating the argument 'x' in selecting a method for function 'stack': object 'cabins_bin2_name' not found plot(cabins_bin1_2, main = c(\"Binarized map setting null to 0\", \"Binarized map keeping null\")) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'plot': object 'cabins_bin1_2' not found  # binarize the map with multiple break values  # first create a continuous map cont_map_name <- calc_influence_nearest(name_var, zoi = 1000, transform = \"exp_decay\",                                         where = \"GRASS\", overwrite = T) #> Error in calc_influence_nearest(name_var, zoi = 1000, transform = \"exp_decay\",     where = \"GRASS\", overwrite = T): could not find function \"calc_influence_nearest\" # binarize cabins_bin2vals_name <- grass_binarize(cont_map_name, output = \"cabins_bin\",                                        breaks = c(0.3, 0.5), overwrite = T) #> Error in doGRASS(cmd, flags = flags, ..., parameters = parameters, echoCmd = echoCmd,     legacyExec = legacyExec): object 'cont_map_name' not found # visualize cabins_bin2vals <- rgrass7::readRAST(c(cont_map_name, cabins_bin2vals_name)) %>%   raster::stack() %>%   terra::rast() #> Warning: Package rgrass7 is transitioning to package rgrass for GRASS GIS 8. #> 'readRAST' is deprecated. Use 'read_RAST' instead. #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'rast': error in evaluating the argument 'x' in selecting a method for function 'stack': object 'cont_map_name' not found plot(cabins_bin2vals,      main = c(\"Original map\",               \"Binarized map, break = 0.3\",               \"Binarized map, break = 0.5\")) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'plot': object 'cabins_bin2vals' not found"},{"path":"https://ninanor.github.io/oneimpact/reference/grass_find_layer.html","id":null,"dir":"Reference","previous_headings":"","what":"Find layers within GRASS GIS with multiple patterns — grass_find_layer","title":"Find layers within GRASS GIS with multiple patterns — grass_find_layer","text":"Find layers within GRASS GIS multiple patterns","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/grass_find_layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find layers within GRASS GIS with multiple patterns — grass_find_layer","text":"","code":"grass_find_layer(   list_patterns,   layers_grass = NULL,   type = \"raster\",   pattern = \"*\",   mapset = \"PERMANENT\" )"},{"path":"https://ninanor.github.io/oneimpact/reference/grass_find_layer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find layers within GRASS GIS with multiple patterns — grass_find_layer","text":"list_patterns [list,character]  List strings, corresponding pattern searched names layers within GRASS GIS mapset. patterns filtered one , order listed. layers_grass [vector,character]  Vector strings names maps assessed, within GRASS GIS mapset, ones created g.list module. NULL (default), list maps within GRASS GIS mapset assessed within function. type [character(1)=\"raster\"]  Type layer listed within GRASS GIS mapset (e.g. \"raster\", \"vector\"), layers_grass NULL. pattern [character]  Regular expression used list maps within GRASS GIS mapset, layers_grass NULL. Default \"*\", maps given type listed. mapset [character(1)=\"PERMANENT\"]  Name mapset maps listed, layers_grass NULL. Default \"PERMANENT\".","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/grass_find_layer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find layers within GRASS GIS with multiple patterns — grass_find_layer","text":"One strings names maps within GRASS GIS mapset.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/grass_v2rast_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Rasterizes a vector counting the number of features in each pixel — grass_v2rast_count","title":"Rasterizes a vector counting the number of features in each pixel — grass_v2rast_count","text":"Add within arguments grass functions options/parameters","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/grass_v2rast_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rasterizes a vector counting the number of features in each pixel — grass_v2rast_count","text":"","code":"grass_v2rast_count(   x,   output = paste0(x, \"_count\"),   column = NULL,   input_as_region = FALSE,   align = NULL,   remove_intermediate = TRUE,   quiet = TRUE,   verbose = FALSE,   overwrite = FALSE,   ... )"},{"path":"https://ninanor.github.io/oneimpact/reference/grass_v2rast_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rasterizes a vector counting the number of features in each pixel — grass_v2rast_count","text":"x Input vector map. output Output map name. column [chracter(1)=NULL  Default NULL. NULL, name column input vector x corresponds column summed count number features pixel output raster map. NULL, column created temporary vector, values equal 1. input_as_region [logical(1)=FALSE]  Default FALSE. Whether GRASS GIS computational region set within function (extent x) . FALSE, current computational region used. align [character(1)=NULL]  Name raster map align computational region produce output map.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/grass_v2rast_count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rasterizes a vector counting the number of features in each pixel — grass_v2rast_count","text":"","code":"# libraries library(rgrass7) library(raster) library(terra) library(dplyr) library(sf)  # connect to grass gis 7.8 grassdir <- system(\"grass78 --config path\", intern = T) gisDB <- \"/data/grass\" loc <- \"ETRS_33N/\" ms <- \"u_bb_cuminf\" rgrass7::initGRASS(gisBase = grassdir,                    home = tempdir(),                    override = T,                    gisDbase = gisDB,                    location = loc,                    mapset = ms) #> Warning: cannot create dir '/data/grass', reason 'Permission denied' #> Warning: cannot create dir '/data/grass/ETRS_33N', reason 'No such file or directory' #> Warning: cannot create dir '/data/grass/ETRS_33N//PERMANENT', reason 'No such file or directory' #> Warning: cannot create dir '/data/grass/ETRS_33N//u_bb_cuminf', reason 'No such file or directory' #> Warning: running command 'g.version' had status 1 #> Error in if (gv == \"sh: line 1: g.version: command not found\") {    compatible <- as.logical(NA)    attr(compatible, \"message\") <- gv    return(compatible)}: argument is of length zero  # input region rgrass7::use_sf() #> Error in rgrass7::use_sf(): sf or stars is not available. You need both packages installed. (s <- system.file(\"vector/study_area.gpkg\", package = \"oneimpact\")) #> [1] \"/home/runner/work/_temp/Library/oneimpact/vector/study_area.gpkg\" test_region_name <- \"region_test_oneimpact_pkg\" sf::st_read(s) %>%   rgrass7::writeVECT(vname = test_region_name, v.in.ogr_flags = \"overwrite\") #> Warning: Package rgrass7 transitioning to package rgrass for GRASS 8. #> 'writeVECT is deprecated. Use 'write_VECT' instead. #> Error in rgrass7::writeVECT(., vname = test_region_name, v.in.ogr_flags = \"overwrite\"): rgdal not available  # set region rgrass7::execGRASS(\"g.region\", vector = test_region_name, res = \"100\", flags = c(\"p\")) #> Error in rgrass7::execGRASS(\"g.region\", vector = test_region_name, res = \"100\",     flags = c(\"p\")): The command: #> g.region -p vector=region_test_oneimpact_pkg res=100 #> produced an error (1) during execution: #> access: No such file or directory #> ERROR: LOCATION <\/data/grass/ETRS_33N/> not available  # input vector (c <- system.file(\"vector/cabins_vect.gpkg\", package = \"oneimpact\")) #> [1] \"/home/runner/work/_temp/Library/oneimpact/vector/cabins_vect.gpkg\" cabins_vect_name <- \"private_cabins_vect\" sf::st_read(c) %>%   rgrass7::writeVECT(vname = cabins_vect_name, v.in.ogr_flags = \"overwrite\") #> Warning: Package rgrass7 transitioning to package rgrass for GRASS 8. #> 'writeVECT is deprecated. Use 'write_VECT' instead. #> Error in rgrass7::writeVECT(., vname = cabins_vect_name, v.in.ogr_flags = \"overwrite\"): rgdal not available  # rasterize with count, creating a new temp_vector cabins_count_name <- grass_v2rast_count(cabins_vect_name, output = \"cabins_count\",                                         quiet = F, overwrite = T) #> Error in parseGRASS(cmd, legacyExec = legacyExec): The command #>    v.in.region --interface-description #> produced an error (1) during execution: #>    access: No such file or directoryERROR: LOCATION <\/data/grass/ETRS_33N/> not available  # rasterize with count, without creating a temporary vector cabins_count_name <- grass_v2rast_count(cabins_vect_name, output = \"cabins_count\",                                         column = \"value\", quiet = F, overwrite = T) #> Error in parseGRASS(cmd, legacyExec = legacyExec): The command #>    v.out.ascii --interface-description #> produced an error (1) during execution: #>    access: No such file or directoryERROR: LOCATION <\/data/grass/ETRS_33N/> not available  # visualize rgrass7::use_sp() #> Error in rgrass7::use_sp(): sp or rgdal is not available. You need both packages installed. rgrass7::readRAST(cabins_count_name) %>%   raster::raster() %>%   terra::rast() %>%   plot(main = \"Number of private cabins\") #> Warning: Package rgrass7 is transitioning to package rgrass for GRASS GIS 8. #> 'readRAST' is deprecated. Use 'read_RAST' instead. #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'plot': error in evaluating the argument 'x' in selecting a method for function 'rast': error in evaluating the argument 'x' in selecting a method for function 'raster': object 'cabins_count_name' not found  # remove rasters created to_remove_vect <- c(test_region_name, cabins_vect_name) to_remove_rast <- c(cabins_count_name) #> Error in eval(expr, envir, enclos): object 'cabins_count_name' not found # rgrass7::execGRASS(\"g.remove\", type = \"vect\", name = to_remove_vect, flags = \"f\") # rgrass7::execGRASS(\"g.remove\", type = \"rast\", name = to_remove_rast, flags = \"f\")"},{"path":"https://ninanor.github.io/oneimpact/reference/isolation.html","id":null,"dir":"Reference","previous_headings":"","what":"Isolation and mean isolation of points in space — isolation","title":"Isolation and mean isolation of points in space — isolation","text":"Measures isolation mean isolation set points space. isolation() creates random points landscape calculates nearest neighbor distance another set points passed input, x. mean_isolation() calculates average isolation calculated isolation().","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/isolation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isolation and mean isolation of points in space — isolation","text":"","code":"isolation(x, n_rand = 100, ext = c(0, 1, 0, 1), lonlat = FALSE)  mean_isolation(x, n_rand = 100, ext = c(0, 1, 0, 1), lonlat = FALSE)"},{"path":"https://ninanor.github.io/oneimpact/reference/isolation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isolation and mean isolation of points in space — isolation","text":"x [data.frame] data.frame (x,y) coordinates columns. n_rand [numeric(1)=100]  Number random points created space, compute distance x. ext [numeric(x)=c(0,1)] Extent space within random positions created c(x ymin, x ymax). lonlat [logical(1)=FALSE]  Whether distance points calculated WGS ellipsoid (lonlat = TRUE) plane (lonlat = FALSE). See raster::pointDistance() details.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/isolation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Isolation and mean isolation of points in space — isolation","text":"isolation() returns distance random point nearest neighbor point x. mean_isolation() returns average nearest neighbor distance random positions points x.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/isolation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Isolation and mean isolation of points in space — isolation","text":"far function works square landscape. future can implement polygons rasters masks null cells necessary, approach similar set_points_sample.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/isolation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isolation and mean isolation of points in space — isolation","text":"","code":"pts <- set_points(n_features = 100, method = \"random\", centers = 1, width = 0.1)[[1]] isolation(pts) #>   [1] 0.068346245 0.082614985 0.058174858 0.081319086 0.084725369 0.003557386 #>   [7] 0.064648763 0.021202851 0.053834044 0.029531420 0.033879227 0.010220870 #>  [13] 0.016228332 0.041959348 0.023929249 0.037355686 0.005631982 0.065699796 #>  [19] 0.029028647 0.026111269 0.035569254 0.025759145 0.068757861 0.042535760 #>  [25] 0.021589793 0.091196855 0.051081656 0.037227706 0.057208288 0.084117433 #>  [31] 0.061377869 0.050967412 0.010845361 0.047156657 0.042641689 0.075199765 #>  [37] 0.024262825 0.018863884 0.009532514 0.016928864 0.020732317 0.051164018 #>  [43] 0.086500614 0.044925689 0.084857044 0.060656043 0.064578039 0.084020264 #>  [49] 0.125731939 0.052997937 0.065961365 0.010502925 0.037012062 0.066091656 #>  [55] 0.035831316 0.059872024 0.041850616 0.063150720 0.029502709 0.089315538 #>  [61] 0.067119525 0.059721790 0.057099522 0.062249806 0.007762248 0.047642202 #>  [67] 0.019330189 0.054723474 0.061159675 0.012392616 0.008340875 0.015367765 #>  [73] 0.015273659 0.047029464 0.033976941 0.017484956 0.031713484 0.030418270 #>  [79] 0.023547088 0.003290354 0.074986792 0.048155446 0.080053944 0.075107117 #>  [85] 0.073839792 0.017840702 0.031622227 0.105977163 0.054306101 0.062912255 #>  [91] 0.005764827 0.040389356 0.087272434 0.025929543 0.039309890 0.037133091 #>  [97] 0.053401900 0.038755540 0.066199279 0.043862414 0.057654788 mean_isolation(pts) #> [1] 0.04878451"},{"path":"https://ninanor.github.io/oneimpact/reference/multifit_multiscale.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluation of multiple covariate effects at multiple scales — multifit_multiscale","title":"Evaluation of multiple covariate effects at multiple scales — multifit_multiscale","text":"Evaluation multiple covariate effects multiple scales","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/multifit_multiscale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluation of multiple covariate effects at multiple scales — multifit_multiscale","text":"","code":"multifit_multiscale(   mod,   mod_comparison_df,   data,   formula = NULL,   weights = NULL,   args = NULL,   max_models = 10000,   corr_check = TRUE,   corr_criterion = c(\"usdm::vifcor\", \"usdm::vifstep\")[1],   corr_threshold = 0.7,   progress = FALSE,   verbose = FALSE,   ... )"},{"path":"https://ninanor.github.io/oneimpact/reference/multifit_single.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluation of single covariate effects at multiple scales or zones of influence (ZoI) — multifit_single","title":"Evaluation of single covariate effects at multiple scales or zones of influence (ZoI) — multifit_single","text":"Evaluation single covariate effects multiple scales zones influence (ZoI)","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/multifit_single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluation of single covariate effects at multiple scales or zones of influence (ZoI) — multifit_single","text":"","code":"multifit_single(   mod,   multief,   data,   formula = NULL,   args = NULL,   criterion = \"AIC\",   site_id = NULL,   signif = TRUE,   alpha = 0.05,   plot_est = FALSE,   print_sum = FALSE,   xlab = \"Radius [m]\",   ylab = NULL,   labels = NULL,   type = \"b\",   pch = c(1, 16) )"},{"path":"https://ninanor.github.io/oneimpact/reference/multifit_single.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Evaluation of single covariate effects at multiple scales or zones of influence (ZoI) — multifit_single","text":"https://github.com/phuais/multifit","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/multifit_single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluation of single covariate effects at multiple scales or zones of influence (ZoI) — multifit_single","text":"mod [character(1)]  String depicting statistical function applied (e.g. \"lm\", \"glm\", \"glmer\"). multief [character]  Vector containing names columns input data, corresponding spatial attribute covariate whose scale effect zone influence assessed. names correspond covariate calculated multiple zone influence radii scales. data [data.frame] data.frame containing response variable model predictor variables, including covariate measured multiple scales ZoI radii,  whose fit assessed. formula [character,formula]  String depicting statistical formula applied models. must include least main response variable predictor variable named \"multief\" (e.g. response_variable ~ multief), corresponding covariate specified multief parameter. args [character]  Character vector additional argument/s models (e.g. args = c(\"family = poisson\") Poisson regression glm). criterion [character]  String depicting criterion used selection best model among various spatial scales (.e. one strongest relationship response variable). can one three options: ‘R2’ (R-squared, .e. coefficient determination, available model type mod), ‘AIC’ (Akaike Information Criterion), ‘BIC’ (Bayesian Information Criterion). Alternatively, user may use function calculation different criterion. case, user must specify name function first element vector, model-selection criterion (‘max’ ‘min’ value criterion, R-squared-like AIC-like criteria, respectively) second element (e.g. criterion = c(‘my_function’, ‘max’)). site_id [character] string depicting column name data.frame holding identity different sites. relevant summary landscape attributes. signif [logical(1)=TRUE]  Differentiate non-significant significant models plot different point shapes? alpha [numeric(1)=0.95]  Numeric value, 0 1. Statistical significance level (relevant signif = TRUE). ... parameters passed multifit function.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/multifit_single.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Evaluation of single covariate effects at multiple scales or zones of influence (ZoI) — multifit_single","text":"Huais, PY. 2018. multifit: R function multi-scale analysis landscape ecology. Landscape Ecology, 33: 1023. https://doi.org/10.1007/s10980-018-0657-5","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/multifit_single.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Evaluation of single covariate effects at multiple scales or zones of influence (ZoI) — multifit_single","text":"Pablo Yair Huais <phuais@gmail.com>","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/multifit_single_multivar.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluation of single covariate effects at multiple scales for multiple covariates — multifit_single_multivar","title":"Evaluation of single covariate effects at multiple scales for multiple covariates — multifit_single_multivar","text":"Evaluation single covariate effects multiple scales multiple covariates","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/multifit_single_multivar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluation of single covariate effects at multiple scales for multiple covariates — multifit_single_multivar","text":"","code":"multifit_single_multivar(   mod,   covariates,   data,   formula = NULL,   args = NULL,   criterion = \"AIC\",   corr_check = TRUE,   corr_criterion = c(\"usdm::vifcor\", \"usdm::vifstep\")[1],   corr_threshold = 0.7,   print_best = 5,   ... )"},{"path":"https://ninanor.github.io/oneimpact/reference/multifit_single_multivar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluation of single covariate effects at multiple scales for multiple covariates — multifit_single_multivar","text":"covariates [character]  List names covariates tested, pattern within names differentiate among .","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/plot_zoi1d.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the functions for the nearest and cumulative zone of influence in 1 dimension — plot_zoi1d","title":"Plot the functions for the nearest and cumulative zone of influence in 1 dimension — plot_zoi1d","text":"Plots functions represent zone influence (ZoI) 1 dimensional space, illustration. one value points (location infrastructure sources disturbance), two metrics might plotted: ZoI nearest feature cumulative ZoI. ZoI nearest feature corresponds maximum ZoI value infrastructure position. cumulative ZoI corresponds sum ZoI infrastructure position.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/plot_zoi1d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the functions for the nearest and cumulative zone of influence in 1 dimension — plot_zoi1d","text":"","code":"plot_zoi1d(   points,   radius,   fun = exp_decay,   zoi_metric = c(\"nearest\", \"cumulative\")[1],   range_plot = c(0, 12),   step = 0.01,   na.rm = TRUE,   return_df = FALSE,   ... )"},{"path":"https://ninanor.github.io/oneimpact/reference/plot_zoi1d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the functions for the nearest and cumulative zone of influence in 1 dimension — plot_zoi1d","text":"points [numeric]  Vector values x axis infrastructure located, 1 dimension (broadly, location sources disturbance spatial variables, point origin ZoI functions). radius [numeric(1)]  Radius zone influence (ZoI), distance ZoI vanishes goes given minimum limit value. See zoi_functions details. fun [function]  decay function represents Zone Influence (ZoI). Different functions might represent different shapes decay ZoI. See zoi_functions examples. zoi_metric [character(1)=\"nearest\"]{\"nearest\", \"cumulative\"}  metric zone influence plotted. \"nearest\"(default), ZoI nearest feature plotted. \"cumulative\", cumulative ZoI plotted. range_plot [numeric(2)=c(0,12)]  vector c(xmin, xmax) x range ZoI plot. step [numeric(1)=0.01]  Size step increment used define series x positions ZoI computed, within x range defined range_plot. return_df [logical(1)=FALSE]  TRUE, data.frame x values corresponding ZoI values returned, besides plot. ... Additional parameters passed ZoI decay function fun.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/plot_zoi1d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the functions for the nearest and cumulative zone of influence in 1 dimension — plot_zoi1d","text":"ggplot object nearest cumulative influence plot. return_df = TRUE, returns list ggplot object data.frame  values x (position 1d space) y (ZoI value).","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/plot_zoi1d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot the functions for the nearest and cumulative zone of influence in 1 dimension — plot_zoi1d","text":"practice, plot_zoi1d() computes ZoI value feature whose locations 1 dimension defined points calculates maximum (ZoI nearest) sum (cumulative ZoI) values. done series points 1 dimensional space range range_plot (steps defined step) plotted. add: options normalization, prob etc.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/plot_zoi1d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the functions for the nearest and cumulative zone of influence in 1 dimension — plot_zoi1d","text":"","code":"# one point, exponential decay plot_zoi1d(0, radius = 3, zoi_limit = 0.05,            fun = exp_decay, range_plot = c(0, 5), zoi_metric = \"nearest\")   # exponential decay points <- c(0, 4.5, 7, 7.5) plot_zoi1d(points, radius = 3, fun = exp_decay, range_plot = c(0, 12),            zoi_metric = \"nearest\")  plot_zoi1d(points, radius = 3, fun = exp_decay, range_plot = c(0, 12),            zoi_metric = \"cumulative\")   # threshold plot_zoi1d(points, radius = 3, fun = threshold_decay, range_plot = c(0, 12),            zoi_metric = \"nearest\")  plot_zoi1d(points, radius = 3, fun = \"step_decay\", range_plot = c(0, 12),            zoi_metric = \"cumulative\")   # linear plot_zoi1d(points, radius = 3, fun = bartlett_decay, range_plot = c(0, 12),            zoi_metric = \"nearest\")  plot_zoi1d(points, radius = 3, fun = \"linear_decay\", range_plot = c(0, 12),            zoi_metric = \"cumulative\")   # gaussian plot_zoi1d(points, radius = 3, fun = gaussian_decay, range_plot = c(0, 12),            zoi_metric = \"nearest\")  plot_zoi1d(points, radius = 3, fun = \"half_norm_decay\", range_plot = c(0, 12),            zoi_metric = \"cumulative\", return_df = TRUE) # also return the data.frame #> $zoi_plot  #>  #> $zoi_df #> # A tibble: 1,201 × 2 #>        x     y #>    <dbl> <dbl> #>  1  0    1.00  #>  2  0.01 1.00  #>  3  0.02 1.00  #>  4  0.03 1.00  #>  5  0.04 1.00  #>  6  0.05 1.00  #>  7  0.06 1.00  #>  8  0.07 1.00  #>  9  0.08 0.999 #> 10  0.09 0.999 #> # … with 1,191 more rows #>"},{"path":"https://ninanor.github.io/oneimpact/reference/raster_rescale.html","id":null,"dir":"Reference","previous_headings":"","what":"Rescale raster values — raster_rescale","title":"Rescale raster values — raster_rescale","text":"Rescales raster values given range.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/raster_rescale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rescale raster values — raster_rescale","text":"","code":"raster_rescale(x, to = c(0, 1), from = NULL)"},{"path":"https://ninanor.github.io/oneimpact/reference/raster_rescale.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rescale raster values — raster_rescale","text":"x [SpatRaster]  Raster object colletion rasters whose values rescaled. [numeric(2)=NULL]  Range original values (format c(min,max)) raster rescaled. NULL, minimum maximum values x used.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/raster_rescale.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rescale raster values — raster_rescale","text":"raster object (collection rasters) values rescaled given range (e.g. interval 0,1).","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/raster_rescale.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rescale raster values — raster_rescale","text":"","code":"library(terra)  f <- system.file(\"raster/cabins.tif\", package = \"oneimpact\") cabins <- terra::rast(f)  # calculate influence ni <- calc_zoi_nearest(cabins, radius = 1000, type = \"exp_decay\") ci <- calc_zoi_cumulative(cabins, zoi_radius = 1000, type = \"exp_decay\",                           zeroAsNA = TRUE) #> Error in oneimpact::filter_create(r0, radius = radius, type = type, zoi_limit = zoi_limit,     zoi_hl_ratio = zoi_hl_ratio, half_life = half_life, max_dist = max_dist,     min_intensity = min_intensity, normalize = normalize, ...): unused argument (zoi_radius = 1000) plot(c(ni, ci)) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'plot': object 'ci' not found  # rescale plot(raster_rescale(ci)) # rescale to [0,1] #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'plot': error in evaluating the argument 'x' in selecting a method for function 'global': object 'ci' not found plot(raster_rescale(c(ni, ci))) # rescale both to [0,1] #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'plot': error in evaluating the argument 'x' in selecting a method for function 'global': object 'ci' not found plot(raster_rescale(c(ni, ci), to = c(0, 100))) # rescale to [0,100] #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'plot': error in evaluating the argument 'x' in selecting a method for function 'global': object 'ci' not found plot(raster_rescale(c(ni, ci), from = c(0, 50))) # rescale to [0,1] from [0,50] #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'plot': error in evaluating the argument 'x' in selecting a method for function 'split': object 'ci' not found"},{"path":"https://ninanor.github.io/oneimpact/reference/rescale_coefficients.html","id":null,"dir":"Reference","previous_headings":"","what":"Rescale standardized coefficients back to their original range after model fitting — rescale_coefficients","title":"Rescale standardized coefficients back to their original range after model fitting — rescale_coefficients","text":"Rescale standardized coefficients back original range model fitting","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/rescale_coefficients.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rescale standardized coefficients back to their original range after model fitting — rescale_coefficients","text":"","code":"rescale_coefficients(model, data)"},{"path":"https://ninanor.github.io/oneimpact/reference/set_points.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate points in a landscape — set_points","title":"Simulate points in a landscape — set_points","text":"function simulates point patterns space rasterize . idea mimic spatial distribution point-type infrastructure, houses, cabins, turbines, instance. function returns list position points binary raster 1 points NA elsewhere. created raster define weights, base raster also returned output.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/set_points.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate points in a landscape — set_points","text":"","code":"set_points(   n_features = 1000,   method = c(\"mobsim\", \"regular\", \"random\", \"raster\", \"NLMR\")[1],   centers = 1,   width = 0.05,   base_raster = NULL,   nlmr_function = \"nlm_mpd\",   point_coordinates = NULL,   res = 0.1,   extent_x = c(0, 1),   extent_y = c(0, 1),   buffer_around = 0,   return_base_raster = TRUE,   use_terra = TRUE,   crs = \"\",   ... )"},{"path":"https://ninanor.github.io/oneimpact/reference/set_points.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate points in a landscape — set_points","text":"n_features [integer(1)=1000]  Total number features spread space. method [character(1)]{\"mobsim\", \"regular\", \"random\", \"raster\", \"NLMR\"}  Method used simulate points space. mobsim uses function mobsim::sim_thomas_community() mobsim package simulate points. raster uses base raster map input define weights simulate random points. NLMR creates neutral landscape model using NLMR package uses input base raster. See Details information. centers [integer(1)=1]  Number centers around features placed. Used method = \"mobsim\". width [numeric(1)=0.05]  Mean distance features cluster center cluster. Used method = \"mobsim\". base_raster [RasterLayer=NULL]  Base raster define weights creating random points. Used method = \"raster\". nlmr_function [character(1)=\"nlm_mpd\"]  Name function NLMR package used create base raster, used define weights creating random points. Used method = \"NLMR\". point_coordinates [data.frame=NULL] data.frame (x,y) columns coordinates already taken elsewhere. option intended points' coordinates already generated taken real landscape. case, points simulated just rasterized (distances derived variables might calculated). res [numeric(1)=0.1]  Resolution output raster. extent_x, entent_y [numeric vector(2)=c(0,1)]  Vector representing minimum maximum extent x y within points placed, format c(min,max). buffer_around [numeric(1)=0.1]  Size buffer around extent landscape, avoid edge effects calculating densities using neighborhood analysis. return_base_raster [logical(1)=TRUE]  Whether base_raster returned output list. NULL method = \"mobsim\". ... arguments passed input NLMR functions, defined nlmr_function argument.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/set_points.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate points in a landscape — set_points","text":"list three elements: (1) pts, coordinates (x,y) simulated points; (2) rast, binary raster containing landscape, 1 points NA elsewhere; (3) base_rast, base raster used weigh simulation points. method = \"mobsim\" \"regular\" \"random\", base_rast NULL.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/set_points.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate points in a landscape — set_points","text":"method = \"mobsim\", function builds upon function mobsim::sim_thomas_community() mobsim package. Originally function intended simulate positions multiple species context species abundance distribution studies, fits well case single species (point patterns single type feature). case, points simulated based number centers/patches points width. method = \"raster\", function uses input raster (defined argument base_raster) define probabilities setting given point certain pixel space. method = \"NLMR\", function also uses raster define probabilities setting given point certain pixel space, raster created function NLMR package. function name defined argument nlmr_function arguments must defined additional parameters set_points(). IMPROVE: implement rasterization terra package","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/set_points.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate points in a landscape — set_points","text":"","code":"#----- # using mobsim library(terra) library(mobsim)  set.seed(1234)  # gradient distribution ext <- 30000 wd <- ext/5 pts <- set_points(n_features = 1000, centers = 1,                   width = wd, res = 100,                   extent_x = c(0, ext), extent_y = c(0, ext)) plot(pts$pts)  plot(pts$rast, col = \"black\")   # one focus of features, with buffer around wd <- ext/20 pts <- set_points(n_features = 1000, centers = 1,                   width = wd, res = 100,                   extent_x = c(0, ext), extent_y = c(0, ext),                   buffer_around = 10000) plot(pts$pts)  plot(pts$rast, col = \"black\")   #----- # using base raster  # raster set.seed(12) r <- raster::raster(matrix(runif(12),3,4)) |>   raster::disaggregate(fact = 10)  # points from raster pts <- set_points(n_features = 100, method = \"raster\",                   base_raster = r) plot(pts$base_rast)  plot(pts$pts)  plot(pts$rast, col = \"black\")   #----- # using NLMR library(NLMR)  # example NLM set.seed(123) ext <- 300 nlm1 <- NLMR::nlm_mpd(ext, ext, 100, roughness = .5) #> Warning: nlm_mpd changes the dimensions of the RasterLayer if even ncols/nrows are choosen. nlm1[] <- scales::rescale(exp(nlm1[]))  plot(nlm1)  # points pts <- set_points(n_features = 1000, method = \"raster\",                   base_raster = nlm1)  plot(pts$base_rast)  plot(pts$pts)  plot(pts$rast, col = \"black\")   # OR we can do it directly  # points ext <- 30000 pts <- set_points(n_features = 1000, method = \"NLMR\",                   nlmr_function = \"nlm_mpd\",                   roughness = .2,                   res = 100,                   extent_x = c(0, ext), extent_y = c(0, ext)) #> Warning: nlm_mpd changes the dimensions of the RasterLayer if even ncols/nrows are choosen.  plot(pts$base_rast)  plot(pts$pts)  plot(pts$rast, col = \"black\")   #----- # using random or regular  set.seed(123) ext <- 30000 pts <- set_points(n_features = 1000, method = \"random\",                   res = 100,                   extent_x = c(0, ext), extent_y = c(0, ext)) plot(pts$pts)  plot(pts$rast, col = \"black\")   pts <- set_points(n_features = 1000, method = \"regular\",                   res = 100,                   extent_x = c(0, ext), extent_y = c(0, ext)) plot(pts$pts)  plot(pts$rast, col = \"black\")   #----- # using point coordinates as input pt_input <- data.frame(x = c(0.5, 0.7), y = c(0.5, 0.3)) pts <- set_points(point_coordinates = pt_input) plot(pts$pts)  plot(pts$rast, col = \"black\")"},{"path":"https://ninanor.github.io/oneimpact/reference/set_points_from_raster.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate points using input raster as weights — set_points_from_raster","title":"Simulate points using input raster as weights — set_points_from_raster","text":"function simulates point patterns space using values input raster weights probabilities selecting point given location. designed simulate points based  neutral landscape models works input rasters well.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/set_points_from_raster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate points using input raster as weights — set_points_from_raster","text":"","code":"set_points_from_raster(base_raster, n_features = 1000)"},{"path":"https://ninanor.github.io/oneimpact/reference/set_points_from_raster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate points using input raster as weights — set_points_from_raster","text":"base_raster [RasterLayer]  Input raster used defining weights. n_features [integer(1)=1000]  Total number features spread space.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/set_points_from_raster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate points using input raster as weights — set_points_from_raster","text":"data.frame (x,y) coordinates simulated points.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/set_points_from_raster.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate points using input raster as weights — set_points_from_raster","text":"function works first selecting random pixels landscape finding centers, adding random variation within pixel define final point locations. based StackExchange useful answer \"Spacedman\": https://gis.stackexchange.com/questions/224321/randomly-generate-points-using-weights--raster IMPROVE: implement terra package","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/set_points_from_raster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate points using input raster as weights — set_points_from_raster","text":"","code":"#----- # minimal example  # example based on # https://gis.stackexchange.com/questions/224321/randomly-generate-points-using-weights-from-raster library(raster)  # raster set.seed(12) r <- raster::raster(matrix(runif(12),3,4))  # points pts <- set_points_from_raster(r, n_features = 300)  # plot raster::plot(r) points(pts)   # or # library(landscapetools) # library(ggplot2) # landscapetools::show_landscape(r) + #   geom_point(aes(x, y), data = pts)  # with terra r <- terra::rast(r) # points pts <- set_points_from_raster(r, n_features = 300)  #----- # using NLMR library(NLMR)  # example NLM set.seed(123) nlm1 <- NLMR::nlm_mpd(100, 100, 100, roughness = .5) #> Warning: nlm_mpd changes the dimensions of the RasterLayer if even ncols/nrows are choosen.  # points pts <- set_points_from_raster(nlm1, n_features = 1000)  # plot raster::plot(nlm1) points(pts)   # or # landscapetools::show_landscape(nlm1) + #   geom_point(aes(x, y), data = pts)"},{"path":"https://ninanor.github.io/oneimpact/reference/set_points_sample.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate regular or random points in 2D — set_points_sample","title":"Simulate regular or random points in 2D — set_points_sample","text":"function simulates coordinates points either regularly randomly  distributed two dimensions. point patterns can also chosen, see type argument sf::st_sample() function. points generated within input polygon bounding box input raster. spatial object used input, size landscape defined extent_x extent_y parameters. assumes landscape square rectangularly shaped.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/set_points_sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate regular or random points in 2D — set_points_sample","text":"","code":"set_points_sample(   n_features = 1000,   type = c(\"regular\", \"random\")[1],   base_polygon = NULL,   extent_x = c(0, 1),   extent_y = extent_x )"},{"path":"https://ninanor.github.io/oneimpact/reference/set_points_sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate regular or random points in 2D — set_points_sample","text":"n_features [integer(1)=1000]  Total number points spread space. type [character(1)=\"regular\"]{\"regular\", \"random\"} Pattern creation points space. methods also accepted, check type argument sf::st_sample() function. base_polygon [RasterLayer,sfc_POLYGON]  Polygon (class sf sfc) inside points created. RasterLayer, bbox raster used polygon. extent_x, entent_y [numeric vector(2)=c(0,1)]  Vector representing minimum maximum extent x y within points placed, format c(min,max).","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/set_points_sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate regular or random points in 2D — set_points_sample","text":"data.frame (x,y) coordinates simulated points.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/set_points_sample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate regular or random points in 2D — set_points_sample","text":"","code":"library(sf)  pts <- set_points_sample(100) plot(pts)  pts2 <- set_points_sample(100, type = \"random\") plot(pts2)   library(raster) x <- rast(system.file(\"external/test.grd\", package=\"raster\")) pts3 <- set_points_sample(100, base_polygon = x) plot(pts3)"},{"path":"https://ninanor.github.io/oneimpact/reference/study_area.gpkg.html","id":null,"dir":"Reference","previous_headings":"","what":"Study area: a polygon vector data — study_area.gpkg","title":"Study area: a polygon vector data — study_area.gpkg","text":"Dataset containing limits arbitrary study area Southern Norway, used illustrative purposes.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/study_area.gpkg.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Study area: a polygon vector data — study_area.gpkg","text":"geopackage file. Projected CRS: ETRS89 / UTM zone 33N.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/study_area.gpkg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Study area: a polygon vector data — study_area.gpkg","text":"","code":"(s <- system.file(\"vector/study_area.gpkg\", package = \"oneimpact\")) #> [1] \"/home/runner/work/_temp/Library/oneimpact/vector/study_area.gpkg\" sf::st_read(s) #> Reading layer `study_area' from data source  #>   `/home/runner/work/_temp/Library/oneimpact/vector/study_area.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 146900 ymin: 6622800 xmax: 194700 ymax: 6658900 #> Projected CRS: ETRS89 / UTM zone 33N # or terra::vect(s) #>  class       : SpatVector  #>  geometry    : polygons  #>  dimensions  : 1, 1  (geometries, attributes) #>  extent      : 146900, 194700, 6622800, 6658900  (xmin, xmax, ymin, ymax) #>  source      : study_area.gpkg #>  coord. ref. : ETRS89 / UTM zone 33N (EPSG:25833)  #>  names       :   cat #>  type        : <int> #>  values      :     1"},{"path":"https://ninanor.github.io/oneimpact/reference/zoi_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Zone of Influence (ZoI) functions — zoi_functions","title":"Zone of Influence (ZoI) functions — zoi_functions","text":"Computes decay functions represent Zone Influence (ZoI). functions' radius (parameter radius) controls far zone influence infrastructure disturbance reaches, functions' shape (parameter type) represent represent ZoI decays space. Given function shape (type) chosen, rate decay different ZoI functions parameterized based ZoI radius -- e.g slope linear_decay() defined function decreases zero ZoI radius. functions can used transform arrays (Euclidean) distance values (one dimension) rasters (Euclidean) distance (two dimensions) ZoI values. distances might represent distance human infrastructure, sources disturbance, broadly type land use class spatial variable.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/zoi_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Zone of Influence (ZoI) functions — zoi_functions","text":"","code":"dist_decay(   x,   radius = NULL,   type = c(\"exp_decay\", \"gaussian_decay\", \"linear_decay\", \"threshold_decay\")[1],   zoi_limit = 0.05,   origin = 0,   oneside = TRUE,   ... )  threshold_decay(x, radius, intercept = 1, origin = 0, oneside = TRUE)  # S3 method for numeric threshold_decay(x, radius, intercept = 1, origin = 0, oneside = TRUE)  # S3 method for SpatRaster threshold_decay(x, radius, intercept = 1, origin = 0, oneside = TRUE)  step_decay(x, radius, intercept = 1, origin = 0, oneside = TRUE)  bartlett_decay(x, radius, intercept = 1, origin = 0, oneside = TRUE)  # S3 method for numeric bartlett_decay(x, radius, intercept = 1, origin = 0, oneside = TRUE)  # S3 method for SpatRaster bartlett_decay(x, radius, intercept = 1, origin = 0, oneside = TRUE)  tent_decay(x, radius, intercept = 1, origin = 0, oneside = TRUE)  linear_decay(x, radius, intercept = 1, origin = 0, oneside = TRUE)  gaussian_decay(   x,   radius = NULL,   zoi_limit = 0.05,   intercept = 1,   lambda = NULL,   sigma = NULL,   origin = 0,   ... )  half_norm_decay(   x,   radius = NULL,   zoi_limit = 0.05,   intercept = 1,   lambda = NULL,   sigma = NULL,   origin = 0,   ... )  exp_decay(   x,   radius = NULL,   zoi_limit = 0.05,   intercept = 1,   lambda = NULL,   origin = 0,   oneside = TRUE,   half_life = NULL,   zoi_hl_ratio = NULL )"},{"path":"https://ninanor.github.io/oneimpact/reference/zoi_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Zone of Influence (ZoI) functions — zoi_functions","text":"x [numeric,SpatRaster,RasterLayer]  Euclidean distance infrastructure, source disturbance, feature/class interest. can single value, array values, raster object. must necessarily Euclidean distance, preferably distance measured meters, ease interpretation (e.g. geodesic distance). radius [numeric(1)]  Radius zone influence (ZoI), distance ZoI vanishes goes given minimum limit value zoi_limit. See details. type [character(1)=\"Gauss\"]{\"Gauss\", \"exp_decay\", \"bartlett\", \"linear\", \"tent\", \"threshold\", \"step\"}  Type shape decay distance. \"Gauss\" \"half_norm\", ZoI follows half-normal shape: intercept * exp(-lambda * (euclidean_distance^2)). intercept lambda parameters defined -- see details. \"exp_decay\", ZoI follows exponential decay shape: intercept * exp(-lambda * euclidean_distance). intercept lambda parameters defined -- see details. \"bartlett\", \"linear_decay\", \"tent_decay\", ZoI follows linear decay shape within ZoI radius (parameter radius). \"threshold\" \"step\", constant influence consider within zone influence radius (parameter radius). pixels closer radius infrastructure considered \"influence\" nearest feature, constant influence value defined intercept parameter, values/pixels beyond radius assumed zero influence. zoi_limit [numeric(1)=0.05]  non-vanishing functions (e.g. exp_decay, gaussian_decay), value used set relationship ZoI radius decay functions: radius defined minimum distance x ZoI assumes values zoi_limit. default 0.05. parameter used radius NULL. origin [numeric(1)=0]  position (1 dimension) located infrastructure source disturbance? Default zero. raster objects, parameter ignored. oneside [logical(1)=TRUE]  FALSE, negative distance values considered symmetrically transformation always positive. parameter meaningful x vector values, raster object. intercept [numeric(1)=1]  Maximum value ZoI function distance disturbance sources zero (x = 0). threshold_decay step_decay functions, intercept constant value Zone Influence within ZoI radius. ZoI functions, intercept value functions origin (sources disturbance located, .e. x = 0). Default intercept = 1. lambda [numeric(2)=NULL]  gaussian_decay exp_decay functions, lambda decay parameter Gaussian exponential decay function. Notice interpretation lambda different depending function -- see details definitions. Gaussian decay function, value lambda considered radius = NULL sigma = NULL. exponential decay function, value lambda considered radius = NULL half_life = NULL. sigma [numeric(1)=NULL]  Standard deviation Gaussian decay function. related Gaussian decay rate \\(\\lambda\\) lambda = 1/(2*sigma^2). considered compute ZoI gaussian_decay function ZoI radius parameter null (radius = NULL). half_life [numeric(1)=NULL]  Half life exponential decay function, meters (map units, rasters). definition, half life distance exponential decay function reaches 0.5 maximum value. exp_decay function, ZoI radius parameter null (radius = NULL), value exponential half life (half_life = log(2)/lambda) can used parameterize exponential decay function. zoi_hl_ratio [numeric(1)=NULL]  exp_decay function, ZoI radius radius zoi_hl_ratio given half_life NULL, value used set ZoI radius (zoi_limit ignored). zoi_hl_ratio ratio ZoI radius value half life exponential function. instance, radius = 1200 zoi_hl_ratio = 6, means half_life 200. consequence, exponential decay ZoI function decreases 0.5 distance 200, ZoI radius = 1200 defined distance ZoI decreases 0.5**6 = 0.015625.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/zoi_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Zone of Influence (ZoI) functions — zoi_functions","text":"ZoI values given array distance values x numeric, raster object delimiting ZoI x corresponds distance infrastructure disturbance sources 2 dimensions space.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/zoi_functions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Zone of Influence (ZoI) functions — zoi_functions","text":"generic function dist_decay() can used compute ZoI values according functions different shapes (parameter type) radii (parameter radius). Alternatively, specific functions implemented ZoI shape. threshold function (threshold_decay()) linear decay function (linear_decay()), ZoI radius (parameter radius) distance x ZoI function value decreases zero. linear decay, done setting slope linear function -intercept/radius, intercept intercept linear function (, maximum value x = 0). non-vanishing functions approach zero asymptotically (exp_decay(), gaussian_decay()), certain limit value must given define ZoI radius -- ZoI radius defined distance x ZoI function goes limit value. functions, different parameters available setting relationship ZoI function value ZoI radius. functions multiple possible names, sake flexibility: linear_decay(), bartlett_decay(), tent_decay() function; threshold_decay() step_decay() function; gaussian_decay() half_norm_decay() function. Alternatively, dist_decay() can call , given ZoI shape specified parameter type. functions might implemented future.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/zoi_functions.html","id":"definitions","dir":"Reference","previous_headings":"","what":"Definitions","title":"Zone of Influence (ZoI) functions — zoi_functions","text":"formal definitions ZoI functions \\(\\phi(d_i, r)\\), \\(d_i\\) distance feature \\(\\) infrastructure source disturbance \\(r\\) radius zone influence: threshold_decay(): threshold step decay function \\(\\phi_{threshold}\\) positive constant within ZoI radius \\(r\\), null \\(x \\ge r\\): $$ \\phi_{threshold}(d_i, r_k) = c \\text{ } d_i < r, 0 \\text{ otherwise} $$ \\(c\\) constant value (default c = 1). linear_decay(): linear (tent/Bartlett) decay function \\(\\phi_{linear}\\) decreases linearly maximum value \\(c\\) (intercept, default c = 1) zero \\(x \\ge r\\): $$\\phi_{linear}(d_i, r) = c - c/r \\text{ } x < r, \\text{ 0 otherwise}$$ exp_decay(): exponential decay function \\(\\phi_{exp}\\) decreases exponentially maximum value \\(c\\) (default c = 1) rate \\(\\lambda\\), defined \\(r\\) ZoI limit value \\(\\phi_{lim}\\), small ZoI value influence considered negligible: $$\\phi_{exp}(d_i, r, \\phi_{lim}) = c exp(-\\lambda d_i)$$ $$\\lambda = ln(1/\\phi_{lim}) / r$$ context, ZoI radius \\(r\\) distance beyond \\(\\phi_{exp} < \\phi_{lim}\\). gaussian_decay(): Gaussian decay function \\(\\phi_{Gauss}\\) follows Gaussian (half-normal) decay maximum \\(c\\) (default c = 1) decay rate \\(\\lambda\\) defined \\(r\\) ZoI limit value \\(\\phi_{lim}\\), small ZoI value influence considered negligible: $$\\phi_{Gauss}(d_i, r, \\phi_{lim}) = c exp(-\\lambda d_i^2)$$ $$\\lambda = ln(1/\\phi_{lim}) / (r^2)$$ context, ZoI radius \\(r\\) distance beyond \\(\\phi_{exp} < \\phi_{lim}\\). Note \\(\\lambda\\) defined differently gaussian_decay exp_decay functions.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/zoi_functions.html","id":"parameterization","dir":"Reference","previous_headings":"","what":"Parameterization","title":"Zone of Influence (ZoI) functions — zoi_functions","text":"shapes ZoI (parameter type dist_decay()) might parameterized multiple ways. brief description possibility: \"Gauss\" \"half_norm\" shapes, ZoI follows half-normal shape: intercept * exp(-lambda * (euclidean_distance^2)). intercept lambda parameters defined. three ways specifying lambda: radius = NULL (default), lambda parameter specified user. cases () value parameter ignored, even provided. parameter radius provided, rate decay given lambda = log(1/zoi_limit) / (radius**2). words, lambda defined function decreases zoi_limit x = radius. radius = NULL sigma provided, lambda defined lambda = 1/(2*sigma**2). \"exp_decay\" shape, ZoI follows exponential decay shape: intercept * exp(-lambda * euclidean_distance). intercept lambda parameters defined. four ways specifying lambda: radius = NULL (default), lambda parameter specified user. cases () value parameter ignored, even provided. parameter radius provided, rate decay given lambda = log(1/zoi_limit) / radius. words, lambda defined function decreases zoi_limit x = radius. radius = NULL half_life given, lambda defined based half life exponential function -- distance function decreases 1/2. zoi_hl_ratio = NULL, lambda defined lambda = log(2)/half_life. last possibility specify zoi_hl_ratio, ratio ZoI radius half life exponential function. instance, zoi_hl_ratio = 4, means ZoI radius defined 4*half_life. zoi_hl_ratio provided, exponential half_life defined based parameter lambda defined accordingly, based relationship . case, radius ignored, even specified. \"bartlett\", \"linear_decay\", \"tent_decay\" shapes, ZoI follows linear decay shape (y = *x + b) within ZoI radius (parameter radius). intercept linear function (b) given parameter intercept slope () given -intercept/radius. \"threshold\" \"step\" shapes, constant influence consider within zone influence radius (parameter radius). pixels closer radius infrastructure considered \"influence\" nearest feature, constant influence value defined intercept parameter, values/pixels beyond radius assumed zero influence.","code":""},{"path":"https://ninanor.github.io/oneimpact/reference/zoi_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Zone of Influence (ZoI) functions — zoi_functions","text":"","code":"# generic dist_decay function oneimpact::dist_decay(500, radius = 1000, type = \"exp_decay\") #> [1] 0.2236068 oneimpact::dist_decay(500, radius = 1000, type = \"gaussian_decay\") #> [1] 0.4728708 oneimpact::dist_decay(500, radius = 1000, type = \"linear_decay\") #> [1] 0.5 oneimpact::dist_decay(500, radius = 1000, type = \"step_decay\") #> [1] 1  # test the zone of influence functions # here we use ggplot() to illustrate the functions, to make the figures more # widely reproducible # to ease the plots, use the function plot_zoi1d() library(ggplot2)  # exponential decay exp_decay(10, radius = 30) #> [1] 0.3684031  f1 <- ggplot(data.frame(x = c(0, 30)), aes(x = x)) +   stat_function(fun = exp_decay, args = list(radius = 20)) +   labs(x = \"Distance\", y = \"Zone of Influence\") +   theme_bw() f1   # exponential decay - two sides f1_2 <- ggplot(data.frame(x = c(-30, 30)), aes(x = x)) +   stat_function(fun = exp_decay,                 args = list(radius = 20, oneside = FALSE)) +   labs(x = \"Distance\", y = \"Zone of Influence\") +   theme_bw() f1_2   # threshold threshold_decay(5, radius = 10) #> [1] 1 threshold_decay(10, radius = 10) #> [1] 0  f2 <- ggplot(data.frame(x = c(0, 30)), aes(x = x)) +   stat_function(fun = threshold_decay,                 args = list(radius = 20), linetype = 2) +   labs(x = \"Distance\", y = \"Zone of Influence\") +   theme_bw() f2   # threshold - two sides f2_2 <- ggplot(data.frame(x = c(-30, 50)), aes(x = x)) +   stat_function(fun = threshold_decay,                 args = list(radius = 20, oneside = FALSE), linetype = 2) +   labs(x = \"Distance\", y = \"Zone of Influence\") +   theme_bw() f2_2   # linear, tent, or bartlett decay bartlett_decay(5, radius = 10) #> [1] 0.5 bartlett_decay(8, radius = 10) #> [1] 0.2  f3 <- ggplot(data.frame(x = c(0, 30)), aes(x = x)) +   stat_function(fun = bartlett_decay, args = list(radius = 20), linetype = 3) +   labs(x = \"Distance\", y = \"Zone of Influence\") +   theme_bw() f3   # linear, two sides f3_3 <- ggplot(data.frame(x = c(-30, 40)), aes(x = x)) +   stat_function(fun = bartlett_decay,                 args = list(radius = 20, origin = 10, oneside = FALSE), linetype = 3) +   labs(x = \"Distance\", y = \"Zone of Influence\") +   theme_bw() f3_3   # guassian or half normal gaussian_decay(5, sigma = 6) #> [1] 0.7066483  f4 <- ggplot(data.frame(x = c(0, 30)), aes(x = x)) +   stat_function(fun = gaussian_decay,                 args = list(radius = 20, zoi_limit = 0.05), linetype = 4) +   labs(x = \"Distance\", y = \"Zone of Influence\") +   geom_vline(xintercept = 20, linetype = 2, color = \"darkgrey\") +   geom_hline(yintercept = 0.05, linetype = 2, color = \"darkgrey\") +   theme_bw() f4   # half normal - two sides gaussian_decay(5, sigma = 6) #> [1] 0.7066483  f4_2 <- ggplot(data.frame(x = c(-30, 30)), aes(x = x)) +   stat_function(fun = gaussian_decay,                 args = list(radius = 20, zoi_limit = 0.05), linetype = 4) +   labs(x = \"Distance\", y = \"Zone of Influence\") +   geom_vline(xintercept = c(-20, 20), linetype = 2, color = \"darkgrey\") +   geom_hline(yintercept = 0.05, linetype = 2, color = \"darkgrey\") +   theme_bw() f4_2   # plot several ZoI with the same radius f1 +   stat_function(fun = threshold_decay, args = list(radius = 20), linetype = 2) +   stat_function(fun = bartlett_decay, args = list(radius = 20), linetype = 3) +   stat_function(fun = gaussian_decay, args = list(radius = 20, zoi_limit = 0.05), linetype = 4) +   labs(x = \"Distance\", y = \"Zone of Influence\") +   theme_bw()   #--- # applying dist_decay functions for rasters library(terra)  # calculate Euclidean distance f <- system.file(\"raster/cabins.tif\", package = \"oneimpact\") cabins <- terra::rast(f) cabins_dist <- calc_zoi_nearest(cabins, type = \"euclidean\")  # transform Euclidean in distance decay # exponential decay plot(oneimpact::dist_decay(cabins_dist, radius = 1000, type = \"exp_decay\"))  # linear decay plot(oneimpact::dist_decay(cabins_dist, radius = 1000, type = \"tent_decay\"))"}]
