% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calc_zoi_nearest.R
\name{calc_zoi_nearest}
\alias{calc_zoi_nearest}
\title{Calculate the zone of influence from the nearest feature}
\usage{
calc_zoi_nearest(
  x,
  zoi_radius = NULL,
  type = c("Gauss", "exp_decay", "bartlett", "half_norm", "threshold", "step",
    "euclidean", "log", "sqrt")[1],
  where = c("R", "GRASS")[1],
  log_base = exp(1),
  zoi_limit = 0.05,
  zoi_hl_ratio = NULL,
  half_life = NULL,
  exp_decay_parms = c(1, 0.01),
  hnorm_decay_parms = c(1, 20),
  constant_influence = 1,
  dist_offset = 0,
  extent_x_cut = NULL,
  extent_y_cut = NULL,
  plotit = FALSE,
  output_map_name = NULL,
  metric = c("euclidean", "geodesic", "squared", "maximum", "manhattan")[1],
  input_as_region = TRUE,
  remove_intermediate = TRUE,
  print_expression = TRUE,
  quiet = TRUE,
  overwrite = FALSE,
  ...
)
}
\arguments{
\item{x}{\verb{[RasterLayer,SpatRaster]} \cr Raster representing locations of features,
preferentially with value 1 (or any other positive value) where the features
are located and NA elsewhere. Alternatively, \code{x} might be a binary (dummy)
spatial variable representing the presence of linear or area features, with
NA/no-data as background.
\code{x} can be a \code{RasterLayer} from \link{raster} package or a \link{SpatRaster} from
\link{terra} package. If \code{where = "GRASS"}, \code{x} must be a string corresponding
to the name of the input map within a GRASS GIS location and mapset.
Maps without NA as background might be prepared as input for \code{calc_zoi_nearest}
through \href{https://rspatial.org/terra/pkg/4-algebra.html}{raster algebra} in R
and e.g. through the use of the module
\href{https://grass.osgeo.org/grass80/manuals/r.null.html}{\code{r.null}} in GRASS GIS.}

\item{zoi_radius}{\verb{[numeric(1)]} \cr Zone of Influence (ZoI) radius,
the distance at which the ZoI vanishes or goes below a given minimum limit value
\code{zoi_limit}. See \link{zoi_functions} for details. This parameter is
ignored if \code{type = "euclidean"}, \code{type = "log"}, or \code{type = "sqrt"}.}

\item{type}{\verb{[character(1)="Gauss"]\{"Gauss", "exp_decay", "bartlett", "threshold", "step", "euclidean", "log","sqrt"\}} \cr
\itemize{
\item If \code{Gauss} or \code{half_norm}, the ZoI follows a half-normal shape: \cr
\code{N_0 * exp(-lambda * (euclidean_distance^2))}. \code{N_0} and \code{lambda} are
parameters to be defined -- see \link{zoi_functions} for details.
\item If \code{exp_decay}, the ZoI follows an exponential decay shape: \cr
\code{N_0 * exp(-lambda * euclidean_distance)}. \code{N_0} and \code{lambda} are
parameters to be defined -- see \link{zoi_functions} for details.
\item If \code{bartlett}, \code{linear_decay}, or \code{tent_decay}, the ZoI follows a
linear decay shape within the ZoI radius (\code{zoi_radius}).
\item If \code{threshold} or \code{step}, a constant influence is consider within the
zone of influence radius (\code{zoi_radius}). All pixels closer than
\code{zoi_radius} to infrastructure are considered as "under the influence" of
the nearest feature, with a constant influence value defined by the
\code{constant_influence} parameter, and all other pixels are assumed to have
zero influence.
\item If \code{euclidean}, the function returns the Euclidean distance as a
proxy for the ZoI, even though a proper zone of influence is not defined
in this case.
\item If \code{log}, the function returns the log-distance:
\code{log(euclidean_distance, base = log_base)} as a
proxy for the ZoI, even though a proper zone of influence is not defined
in this case.
\item If \code{sqrt}, the functions returns the square rooted distance:
\code{sqrt(euclidean_distance)} as a
proxy for the ZoI, even though a proper zone of influence is not defined
in this case.
}
See details below.
Other options still to be implemented (such as other functions and a
generic user-defined ZoI function as input).}

\item{where}{\verb{[character(1)="R"]\{"R", "GRASS"\}} \cr Where should the
computation be done? Default is \code{"R"}. If \code{where = "GRASS"}, the R session
must be linked to an open GRASS GIS session in a specific location and mapset.}

\item{log_base}{\verb{[numeric(1)=exp(1)]} \cr Base of the logarithm, if \code{type = log}.}

\item{zoi_limit}{\verb{[numeric(1)=0.05]} \cr For non-vanishing functions
(e.g. \code{exp_decay}, \code{gaussian_decay}), this value is used to set the relationship
between the ZoI radius and the decay functions:
\code{zoi_radius} is defined as the minimum distance at which the ZoI assumes values
below \code{zoi_limit}. The default is 0.05. This parameter is used only
if \code{zoi_radius} is not \code{NULL}.}

\item{exp_decay_parms}{\verb{[numeric(2)=c(1,0.01)]} \cr Parameters (\code{N_0}, \code{lambda})
for the exponential decay ZoI, if \code{type = exp_decay}. The value of \code{lambda}
defined here is used only if \code{zoi_radius = NULL} and \code{half_life = NULL},
otherwise one of these parameters is used to determine \code{lambda}.
By default, \code{N_0} is defined as 1, which means the ZoI is 1 where the
infrastructure feature is located, and it decreases as the Euclidean distance
from it increases.}

\item{hnorm_decay_parms}{\verb{[numeric(2)=c(1,20)]} \cr Parameters (\code{N_0}, \code{sigma})
for the half-normal decay ZoI, if \code{type = Gauss} or \code{type = half_normal}.
The value of \code{sigma} defined here is used to define the decay rate \code{lambda}
only if \code{zoi_radius = NULL} and \code{half_life = NULL}, otherwise one of these
parameters is used to determine \code{lambda}. By default, \code{N_0} is defined as 1,
which means the ZoI is 1 where the infrastructure feature is located,
and it decreases as the Euclidean distance from it increases.}

\item{constant_influence}{\verb{[numeric(1)=1]} \cr Constant value of the
ZoI of the nearest feature if \code{type = "threshold"} or \code{type = "step"}.
Default is 1. In this case, all pixels closer to any
infrastructure than the \code{zoi_radius} are classified with this constant value.}

\item{dist_offset}{\verb{[numeric(1)=1]} \cr Number to add to the Euclidean
distance before transforming it, to avoid \code{-Inf}/\code{Inf} values
(e.g. in the case of log transformation). It should be a very small value
compared to the range of values of Euclidean distance, not to influence any
further analyses.}

\item{extent_x_cut, entent_y_cut}{\verb{[numeric vector(2)=c(0,1)]} \cr Vector
representing the minimum and
maximum extent in x and y for the final output, in the format c(min,max).
It is intended to keep only a region of interest, for standardizing the
parameters and region when comparing the resulting ZoI maps with the
cumulative ZoI, calculated through \link{calc_zoi_cumulative}.}

\item{plotit}{\verb{[logical(1)=FALSE]} \cr Should the outputs be plotted along
the calculation? Only used when \code{where = "R"}.}

\item{output_map_name}{\verb{[character(1)=NULL]} \cr Name of the output map name,
to be used only within GRASS (if \code{where = "GRASS"}). By default, this is \code{NULL}
and the output map names are a concatenation of the input map name
(e.g. "map_houses") and the decay function and zoi_radius used
(e.g. for \code{type = "exp_decay"} and \code{zoi_radius = 1000}, the name would be
"map_houses_exp_decay_1000").
This parameter is ignored when the calculations are performed in R
(\code{where = "R"}).}

\item{metric}{\verb{[character(1)="euclidean"]\{"euclidean", "geodesic", "squared", "maximum", "manhattan"\}} \cr
If the calculations are perfomed within GRASS GIS, this is the \code{metric}
argument to calculate the distance
from the infrastructure features with the module \code{r.grow.distance}.
More information at the GRASS GIS documentation for
\href{https://grass.osgeo.org/grass80/manuals/r.grow.distance.html}{this function}.
This parameter is ignored when the calculations are performed in R
(\code{where = "R"}).}

\item{input_as_region}{\verb{[logical(1)=TRUE]} \cr Should the input map \code{x} be
used to redefine the working GRASS region before cumulative ZoI calculation?
If \code{TRUE}, \code{x} is used to define the region with \code{g.region}. If \code{FALSE},
the region previously defined in the GRASS GIS session is used for computation.}

\item{remove_intermediate}{\verb{[logical(1)=TRUE]} \cr Should the intermediate
maps created for computing the output map be excluded in the end of the
process? Only used when \code{where = "GRASS"}.}

\item{print_expression}{\verb{[logical(1)=FALSE]} \cr Should the expression for
transforming the raster of distance should be printed in the prompt?
Only used when \code{where = "GRASS"} for debugging the result of \code{r.mapcalc}.}

\item{quiet}{\verb{[logical(1)=TRUE]} \cr Should GRASS GIS messages be ommited
from the prompt along the computation? Only used when \code{where = "GRASS"}.}

\item{overwrite}{\verb{[logical(1)=FALSE]} \cr If the a map already exists with the
name \code{output_map_name} in the working GRASS GIS location and mapset, should
it be overwritten? Only used when \code{where = "GRASS"}.}

\item{...}{\cr Adittional parameters passed to \code{\link[terra:distance]{terra::distance()}}
or to the ZoI functions (see \link{zoi_functions}) when the
calculations are performed in R.
No additional parameters implemented for computation in GRASS GIS.}
}
\value{
If the calculations are performed in R (\code{where = "R"}), the function
returns a \code{RasterLayer} (or \code{SpatRaster}, according to the class of the input
object) with the zone of influence of the nearest feature. If multiple values
of \code{zoi_radius} are providade, a stack of rasters is returned.
If the calculations are performed in GRASS GIS (\code{where = "GRASS"}),
the maps are kept only within the GRASS GIS location/mapset and the function
returns the name of the calculated maps. \cr
If the computation is done in GRASS GIS, the output is name of
the output raster map within the GRASS GIS location and mapset of the
current session. The user can retrieve these maps to R using
\link[rgrass7:readRAST]{rgrass7::read_RAST} or export them outside GRASS using the
\code{r.out.gdal} module, for instance.
}
\description{
This function takes in a raster with locations or counts of
infrastructure and calculates a raster (or set of rasters, in case there is
more the one value for \code{zoi_radius}) representing the zone of influence (ZoI)
from the neareast feature of that type of infrastructure. Zones of influence
are defined by functions that decay with the Euclidean distance from each
infrastructure and their rate of decay is controlled by the ZoI radius
(\code{zoi_radius}), which defines how far the influence of an infrastructure
feature goes. By default, the Gaussian decay ZoI is calculated, byt other
decay functions might be used (see \link{zoi_funtions} for examples).
The function might also return the Euclidean distance to the nearest feature
or a transformation from it (e.g. log- and sqrt-distance from the nearest
feature).

The procedure might be computed in both R and GRASS GIS. In GRASS, it
requires an active connection between the R session and a GRASS GIS
location and mapset (through the package \link{rgrass7}), and that the input
maps are already loaded within this GRASS GIS mapset.
If the calculations are done in R, the input is a (set of) raster map(s)
and the function returns another (set of) raster map(s). If the calculations
are done within GRASS GIS, the input is the name of a raster map already
loaded in a GRASS GIS location and mapset, and the function returns
only the name of the output map. This map is stored in the the GRASS GIS
location/mapset, and might be retrieved to R through the
\link[rgrass7:readRAST]{rgrass7::read_RAST} function or exported outside GRASS using the
\code{r.out.gdal} module, for instance.
}
\details{
In practice, the function first calculated the Euclidean distance from each
pixel to the nearest feature and then transforms it according to the ZoI
functions. In R, \code{calc_zoi_nearest} makes use of the \link[terra:distance]{terra::distance}
function and the following procedures are made through raster algebra.
In GRASS, the module
\href{https://grass.osgeo.org/grass78/manuals/r.grow.distance.html}{\code{r.grow.distance}}
is used to calculate the Euclidean distance from
the nearest feature and
\href{https://grass.osgeo.org/grass78/manuals/r.mapcalc.simple.html}{\code{r.mapcalc.simple}}
to transform the distance into the different ZoI of the nearest feature.

The input raster \code{x} should have positive values in the pixels where
infrastructure are located and NA/no-data in all other places.
The input raster is supposed to
represent the location of point, line, or polygon infrastructure
(e.g. houses, roads, mining areas), but any landscape variable whose
representation might be one of those would fit here
(e.g. areas of forest or any other habitat type or land cover).
We recommend that the input raster has a metric projection, so that distances
and zones of influence are based on distance to infrastructure measured in meters.
}
\examples{
# Running calc_zoi_nearest through R
library(mobsim)
library(terra)
library(dplyr)
library(sf)

set.seed(1234)

# set points
ext <- 30000
wd <- ext/20
pts <- set_points(n_features = 50, centers = 1,
                  width = wd, res = 100,
                  extent_x = c(0, ext), extent_y = c(0, ext))
plot(pts$pts)
plot(pts$rast)

# calculate distance to the nearest feature
d <- calc_zoi_nearest(pts$rast, type = "euclidean")
plot(d)

# calculate log_dist (the rest is equal)
log_d <- calc_zoi_nearest(pts$rast, type = "log", log_base = 10)
plot(log_d)

# calculate sqrt_dist
sqrt_d <- calc_zoi_nearest(pts$rast, type = "sqrt")
plot(sqrt_d)

# calculate exponential decay zone of influence
# using exp_decay_parms parameter
exp_d1 <- calc_zoi_nearest(pts$rast, type = "exp_decay",
                           exp_decay_parms = c(1, 0.001))
plot(exp_d1)

# calculate exponential decay zone of influence using
# zoi_radius and zoi_limit (default)
radius2 <- 1000 # zoi = 1000m
zoi_limit2 <- 0.05 # here zoi is the distance where the function reaches 0.05
exp_d2 <- calc_zoi_nearest(pts$rast, type = "exp_decay", zoi_radius = radius2,
                           zoi_limit = zoi_limit2)
plot(exp_d2)
# buffer
pts_shp <- pts$pts \%>\%
  sf::st_as_sf(coords = c(1,2))
# zoi = 1000m
pts_shp \%>\%
  sf::st_buffer(dist = radius2) \%>\%
  sf::st_union() \%>\%
  plot(add = T, border = "black")
legend("bottomright", legend = c("ZoI radius"), col = c("black"), lwd = 1.1)

# calculate exponential decay zone of influence using half life parameter
# if half_life = 250 m and zoi_hl_ratio = 4, zoi is 1000 m
half_life3 <- 250 # intensity gets down to 1/16 = 0.06 for 4*half_life=1000m
zoi_hl_ratio3 <- 4 # default
exp_d4 <- calc_zoi_nearest(pts$rast, type = "exp_decay", half_life = half_life3,
                           zoi_hl_ratio = zoi_hl_ratio3)
plot(exp_d4)
# buffer
pts_shp <- pts$pts \%>\%
  sf::st_as_sf(coords = c(1,2))
# half_life = 250m
pts_shp \%>\%
  sf::st_buffer(dist = half_life3) \%>\%
  sf::st_union() \%>\%
  plot(add = T, border = "red")
# zoi = 1000m
pts_shp \%>\%
  sf::st_buffer(dist = half_life3*zoi_hl_ratio3) \%>\%
  sf::st_union() \%>\%
  plot(add = T, border = "black")
legend("bottomright", legend = c("Exponential half-life", "ZoI radius"),
       col = c("red", "black"), lwd = 1.1)

# calculate exponential decay zone of influence using
# zoi_radius parameter and zoi_hl_ratio
zoi_radius4 <- 4000 # intensity gets down to 1/16 = 0.06 for zoi = 4000m, half_life = 1000m
zoi_hl_ratio4 <- 6 # default
exp_d4 <- calc_zoi_nearest(pts$rast, type = "exp_decay", zoi_radius = zoi_radius4,
                           zoi_hl_ratio = zoi_hl_ratio4)
plot(exp_d4)
# buffer
pts_shp <- pts$pts \%>\%
  sf::st_as_sf(coords = c(1,2))
# half_life = 1000m
pts_shp \%>\%
  sf::st_buffer(dist = zoi_radius4/zoi_hl_ratio4) \%>\%
  sf::st_union() \%>\%
  plot(add = T, border = "red")
# zoi = 4000m
pts_shp \%>\%
  sf::st_buffer(dist = zoi_radius4) \%>\%
  sf::st_union() \%>\%
  plot(add = T, border = "black", )
legend("bottomright", legend = c("Exponential half-life", "ZoI radius"),
       col = c("red", "black"), lwd = 1.1)

# bartlett influence, ZOI = 2000m
bart_d <- calc_zoi_nearest(pts$rast, type = "bartlett", zoi_radius = 2000)
plot(bart_d)

# buffer 2000m
pts_shp \%>\%
  sf::st_buffer(dist = 2000) \%>\%
  sf::st_union() \%>\%
  plot(add = T, border = "black")
legend("bottomright", legend = c("Bartlett ZoI 2000m"),
       col = c("black"), lwd = 1.1)

# calculate threshold influence
d <- calc_zoi_nearest(pts$rast, type = "threshold", zoi = 2000)
plot(d)

# Gaussian decay influence
g_d <- calc_zoi_nearest(pts$rast, type = "Gauss", zoi_radius = 2000)
plot(g_d)

# buffer 2000m
pts_shp \%>\%
  sf::st_buffer(dist = 2000) \%>\%
  sf::st_union() \%>\%
  plot(add = T, border = "black")
legend("bottomright", legend = c("Gaussian ZoI 2000m"),
       col = c("black"), lwd = 1.1)

#--------------------
# Running calc_zoi_nearest through GRASS GIS
library(rgrass7)
library(terra)
library(sp)
library(dplyr)

# Load raster data
f <- system.file("raster/cabins.tif", package = "oneimpact")
cabins <- terra::rast(f)

# connect to grass gis 7.8 and create grass location
grassdir <- system("grass78 --config path", intern = T)
gisDB <- "." # create location and mapset in the working directory
loc <- "ETRS_33N/" # name of the location
ms <- "PERMANENT" # name of the mapset
rgrass7::initGRASS(gisBase = grassdir,
                   SG = cabins, # use map to define location projection
                   home = tempdir(),
                   override = T,
                   gisDbase = gisDB,
                   location = loc,
                   mapset = ms)


# define map name within GRASS GIS
cabins_g <- "cabins_example"
# add file to GRASS GIS mapset
rgrass7::write_RAST(cabins, cabins_g, flags = "overwrite")

# check
terra::plot(cabins, col = "black",
            main = "Map of tourist cabins")

#---
# define region in GRASS GIS
rgrass7::execGRASS("g.region", raster = cabins_g,
                   flags = "p")

# Input map name within GRASS GIS
cabins_g

# Euclidean
euclidean_name <- calc_zoi_nearest(cabins_g, type = "euclidean",
                                   where = "GRASS",
                                   quiet = T, overwrite = T)
# Log
log_name <- calc_zoi_nearest(cabins_g, type = "log", log_base = 10,
                             where = "GRASS", quiet = T, overwrite = T)
# Exponential decay ZoI=1000m
expdecay_name <- calc_zoi_nearest(cabins_g, type = "exp_decay",
                                  zoi_radius = 1000,
                                  where = "GRASS", quiet = T, overwrite = T)
# Bartlett decay ZoI=1000m
bartlett_name <- calc_zoi_nearest(cabins_g, type = "bartlett",
                                  zoi_radius = 1000,
                                  where = "GRASS", quiet = T, overwrite = T)

# Threshold influence ZoI = 1000m
threshold_name <- calc_zoi_nearest(cabins_g, type = "threshold",
                                   zoi_radius = 1000,
                                   where = "GRASS", quiet = T, overwrite = T)

# Gaussian influence ZoI = 1000m
gaussian_name <- calc_zoi_nearest(cabins_g, type = "Gauss",
                                  zoi_radius = 1000,
                                  where = "GRASS", quiet = T, overwrite = T)


(all_names <- c(euclidean_name, log_name, expdecay_name,
                bartlett_name, threshold_name, gaussian_name))

# visualize
cabins_zoi_nearest <- rgrass7::read_RAST(all_names, return_format = "terra")

title_plot <- c("Euclidean distance", "Log distance (base 10)",
                "Exponential ZoI 1000m", "Bartlett ZoI 1000m",
                "Threshold ZoI 1000m", "Gaussian ZoI 1000m")
terra::plot(cabins_zoi_nearest, main = title_plot)

# remove rasters created
to_remove_vect <- c(test_region_name, cabins_vect_name)
to_remove_rast <- c(all_names)
# rgrass7::execGRASS("g.remove", type = "vect", name = to_remove_vect, flags = "f")
# rgrass7::execGRASS("g.remove", type = "rast", name = to_remove_rast, flags = "f")
}
\seealso{
See \link{zoi_functions} for some ZoI function shapes. \cr
See also \link[terra:distance]{terra::distance} for details on the calculation of the distance
to the nearest future in R. \cr
See
\href{https://grass.osgeo.org/grass80/manuals/r.mfilter.html}{r.grow.distance},
for details on the calculation of the distance to the nearest future in GRASS. \cr
See \link{calc_zoi_cumulative} for the computation of the cumulative
zone of influence and density of multiple features.
}
