% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calc_zoi_nearest.R
\name{calc_zoi_nearest}
\alias{calc_zoi_nearest}
\title{Calculate the zone of influence from the nearest feature}
\usage{
calc_zoi_nearest(
  x,
  radius = NULL,
  type = c("Gauss", "exp_decay", "bartlett", "half_norm", "threshold", "step",
    "euclidean", "log", "sqrt")[1],
  where = c("R", "GRASS")[1],
  intercept = 1,
  zoi_limit = 0.05,
  lambda = NULL,
  log_base = exp(1),
  dist_offset = 0,
  zeroAsNA = FALSE,
  extent_x_cut = NULL,
  extent_y_cut = NULL,
  g_output_map_name = NULL,
  g_dist_metric = c("euclidean", "geodesic", "squared", "maximum", "manhattan")[1],
  g_input_as_region = FALSE,
  g_remove_intermediate = TRUE,
  g_print_expression = FALSE,
  g_overwrite = FALSE,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{x}{\verb{[RasterLayer,SpatRaster]} \cr Raster representing locations of features,
preferentially with positive value where the features
are located and NA elsewhere. Alternatively, \code{x} might be a binary (dummy)
spatial variable representing the presence of linear or area features, with
NA/no-data as background.
\code{x} can be a \code{RasterLayer} from \link{raster} package or a \link{SpatRaster} from
\link{terra} package. If \code{where = "GRASS"}, \code{x} must be a string corresponding
to the name of the input map within a GRASS GIS location and mapset.

The input raster \code{x} should have positive values in the pixels where infrastructure
are located and NA/no-data in all other places. In R it is also possible to have zeros
as the background and set \code{zeroAsNA = TRUE} for the computation of the ZoI of the
nearest feature.
In GRASS, maps without NA as background might be prepared as input for \code{calc_zoi_nearest()}
through \href{https://grass.osgeo.org/grass78/manuals/r.mapcalc.html}{raster algebra}
and e.g. through the use of the module
\href{https://grass.osgeo.org/grass80/manuals/r.null.html}{\code{r.null}}.}

\item{radius}{\verb{[numeric(1)]} \cr Radius of the zone of influence (ZoI),
the distance at which the ZoI vanishes or goes below a given minimum limit value
\code{zoi_limit}. See \code{\link[=zoi_functions]{zoi_functions()}} for details.
It can be a single value or a vector of values, in which case
several ZoI layers (one for each radius) are created. This parameter is
ignored if \code{type = "euclidean"}, \code{type = "log"}, or \code{type = "sqrt"}.}

\item{type}{\verb{[character(1)="Gauss"]\{"Gauss", "exp_decay", "bartlett", "threshold", "step", "euclidean", "log","sqrt"\}} \cr
Shape of the zone of influence: \cr
\itemize{
\item If \code{Gauss} or \code{half_norm}, the ZoI follows a half-normal shape: \cr
\code{intercept * exp(-lambda * (euclidean_distance^2))}. \code{intercept} and \code{lambda} are
parameters to be defined -- see \code{\link[=zoi_functions]{zoi_functions()}} for details.
\item If \code{exp_decay}, the ZoI follows an exponential decay shape: \cr
\code{intercept * exp(-lambda * euclidean_distance)}. \code{intercept} and \code{lambda} are
parameters to be defined -- see \code{\link[=zoi_functions]{zoi_functions()}} for details.
\item If \code{bartlett}, \code{linear_decay}, or \code{tent_decay}, the ZoI follows a
linear decay shape within the ZoI radius (\code{radius}).
\item If \code{threshold} or \code{step}, a constant influence is considered within the
zone of influence radius (\code{radius}). All pixels closer than
\code{radius} to infrastructure are considered as "under the influence" of
the nearest feature, with a constant influence value defined by the
\code{intercept} parameter, and all other pixels are assumed to have
zero influence.
\item If \code{euclidean}, the function returns the Euclidean distance as a
proxy for the ZoI, even though a proper zone of influence is not defined
in this case.
\item If \code{log}, the function returns the log-distance:
\code{log(euclidean_distance, base = log_base)} as a
proxy for the ZoI, even though a proper zone of influence is not defined
in this case.
\item If \code{sqrt}, the functions returns the square rooted distance:
\code{sqrt(euclidean_distance)} as a
proxy for the ZoI, even though a proper zone of influence is not defined
in this case.
}
See details below.
Other options still to be implemented (such as other functions and a
generic user-defined ZoI function as input).}

\item{where}{\verb{[character(1)="R"]\{"R", "GRASS"\}} \cr Where should the
computation be done? Default is \code{"R"}. If \code{where = "GRASS"}, the R session
must be linked to an open GRASS GIS session in a specific location and mapset.}

\item{intercept}{\verb{[numeric(1)=1]} \cr Maximum value of the ZoI functions at
when the distance from disturbance sources is zero (\code{x = 0}).
For the \code{threshold_decay} and \code{step_decay} functions, \code{intercept} is
the constant value of the Zone of Influence within the ZoI \code{radius}.
For the other ZoI functions, \code{intercept}
is the value of the functions at the origin (where the sources of disturbance
are located, i.e. \code{x = 0}).
Default is \code{intercept = 1}. This parameter is
ignored if \code{type = "euclidean"}, \code{type = "log"}, or \code{type = "sqrt"}.}

\item{zoi_limit}{\verb{[numeric(1)=0.05]} \cr For non-vanishing functions
(e.g. \code{exp_decay}, \code{gaussian_decay}), this value is used to set the relationship
between the ZoI radius and the decay functions:
\code{radius} is defined as the minimum distance at which the ZoI assumes values
below \code{zoi_limit}. The default is 0.05. This parameter is used only
if \code{radius} is not \code{NULL}.}

\item{lambda}{\verb{[numeric(2)=NULL]} \cr For the Gaussian and exponential decay
functions (\code{type = "Gauss"} and \code{type = "exp_decay"}), \code{lambda} is the decay
parameter of the function. Notice that the interpretation of \code{lambda} is different depending on the
the function -- see \code{\link[=zoi_functions]{zoi_functions()}} for definitions.
For the Gaussian decay function, the value for \code{lambda} is only considered if both
\code{radius = NULL} and \code{sigma = NULL}. For the exponential decay function,
the value for \code{lambda} is only considered if both \code{radius = NULL} and \code{half_life = NULL}.}

\item{log_base}{\verb{[numeric(1)=exp(1)]} \cr Base of the logarithm, if \code{type = log}.}

\item{dist_offset}{\verb{[numeric(1)=0]} \cr Number to add to the Euclidean
distance before transforming it, to avoid \code{-Inf}/\code{Inf} values
(e.g. in the case of log transformation). It should be a very small value
compared to the range of values of Euclidean distance, not to influence any
further analyses.}

\item{zeroAsNA}{\verb{[logical(1)=FALSE]} \cr If \code{TRUE} treats cells that are
zero as if they were \code{NA}. Only used for computations in R (\code{where = R}).}

\item{extent_x_cut, entent_y_cut}{\verb{[numeric vector(2)=NULL]} \cr Vector
representing the minimum and
maximum extent in x and y for the final output, in the format c(min,max).
It is intended to keep only a region of interest, for standardizing the
parameters and region when comparing the resulting ZoI maps with the
cumulative ZoI, calculated through \code{\link[=calc_zoi_cumulative]{calc_zoi_cumulative()}}.
If \code{NULL} (default), this parameter is ignored.}

\item{g_output_map_name}{\verb{[character(1)=NULL]} \cr Name of the output map name,
to be used only within GRASS (if \code{where = "GRASS"}). By default, this is \code{NULL}
and the output map names are a concatenation of the input map name
(e.g. \code{"map_houses"}) and the decay function and radius used
(e.g. for \code{type = "exp_decay"} and \code{radius = 1000}, the name would be
\code{"map_houses_exp_decay1000"}).
This parameter is ignored when the calculations are performed in R
(\code{where = "R"}).}

\item{g_dist_metric}{\verb{[character(1)="euclidean"]\{"euclidean", "geodesic", "squared", "maximum", "manhattan"\}} \cr
If the calculations are perfomed within GRASS GIS, this is the \code{metric}
argument to calculate the distance
from the infrastructure features with the module \code{r.grow.distance}.
More information at the GRASS GIS documentation for
\href{https://grass.osgeo.org/grass82/manuals/r.grow.distance.html}{this function}.
This parameter is ignored when the calculations are performed in R
(\code{where = "R"}).}

\item{g_input_as_region}{\verb{[logical(1)=FALSE]} \cr Should the input map \code{x} be
used to redefine the working region in GRASS before the ZoI calculation?
If \code{TRUE}, \code{x} is used to define the region with \code{g.region}. If \code{FALSE},
the region previously defined in the GRASS GIS session is used for computation.
Default is \code{FALSE}. This parameter is ignored when the calculations are performed in R
(\code{where = "R"}).}

\item{g_remove_intermediate}{\verb{[logical(1)=TRUE]} \cr Should the intermediate
maps created for computing the output map be excluded in the end of the
process? Only used when \code{where = "GRASS"}.}

\item{g_print_expression}{\verb{[logical(1)=FALSE]} \cr Should the expression for
transforming the raster of distance into ZoI values should be printed in the prompt?
Only used when \code{where = "GRASS"} and \code{verbose = TRUE} for debugging the
result of \code{r.mapcalc}.}

\item{g_overwrite}{\verb{[logical(1)=FALSE]} \cr If the a map already exists with the
name \code{g_output_map_name} in the working GRASS GIS location and mapset, should
it be overwritten? Only used when \code{where = "GRASS"}.}

\item{verbose}{\verb{[logical(1)=FALSE]} \cr Should messages of the computation steps
be printed in the prompt along the computation?}

\item{...}{\cr Adittional parameters passed to \code{\link[terra:distance]{terra::distance()}}
or to the ZoI functions (see \code{\link[=zoi_functions]{zoi_functions()}}) when the
calculations are performed in R.
No additional parameters implemented for computation in GRASS GIS.}
}
\value{
If the calculations are performed in R (\code{where = "R"}), the function
returns a \code{RasterLayer} (or \code{SpatRaster}, according to the class of the input
object) with the zone of influence of the nearest feature. If multiple values
of \code{radius} are provided, a stack of rasters is returned.
If the calculations are performed in GRASS GIS (\code{where = "GRASS"}),
the maps are kept only within the GRASS GIS location/mapset and the function
returns the name of the calculated maps. \cr
If the computation is done in GRASS GIS, the output is name of
the output raster map(s) within the GRASS GIS location and mapset of the
current session. The user can retrieve these maps to R using
\link[rgrass7:readRAST]{rgrass7::read_RAST} or export them outside GRASS using the
\code{r.out.gdal} module, for instance.
}
\description{
This function takes in a raster with locations or counts of
infrastructure and calculates a raster (or set of rasters, in case there is
more the one value for \code{radius}) representing the zone of influence (ZoI)
from the neareast feature of that type of infrastructure. Zones of influence
are defined by functions that decay with the distance from each
infrastructure and their rate of decay is controlled by the ZoI radius
(\code{radius}), which defines how far the influence of an infrastructure
feature goes. By default, the Gaussian decay ZoI is calculated, but other
decay shapes might be used (see \code{\link[=zoi_functions]{zoi_functions()}} for examples).
The function might also return the distance to the nearest feature
or a transformation from it (e.g. log- and sqrt-distance from the nearest
feature).

The procedure might be computed in both R and GRASS GIS. In GRASS, it
requires an active connection between the R session and a GRASS GIS
location and mapset (through the package \link{rgrass7}), and that the input
maps are already loaded within this GRASS GIS mapset.
If the calculations are done in R, the input is a (set of) raster map(s)
and the function returns another (set of) raster map(s). If the calculations
are done within GRASS GIS, the input is the name of a raster map already
loaded in a GRASS GIS location and mapset, and the function returns
only the name of the output map. This map is stored in the GRASS GIS
location/mapset, and might be retrieved to R through the
\code{\link[rgrass7:readRAST]{rgrass7::read_RAST()}} function or exported outside GRASS using the
\code{r.out.gdal} module, for instance.
}
\details{
In practice, the function \code{calc_zoi_nearest()} first calculates the distance from each
pixel to the nearest feature and then transforms it according to the ZoI
functions. In R, \code{calc_zoi_nearest()} makes use of the \code{\link[terra:distance]{terra::distance()}}
function and the following procedures are made through raster algebra.
In GRASS, the module
\href{https://grass.osgeo.org/grass78/manuals/r.grow.distance.html}{\code{r.grow.distance}}
is used to calculate the Euclidean distance from
the nearest feature and
\href{https://grass.osgeo.org/grass78/manuals/r.mapcalc.simple.html}{\code{r.mapcalc.simple}}
to transform the distance into the different ZoI of the nearest feature.

The input raster \code{x} should have positive values in the pixels where
infrastructure are located and NA/no-data in all other places.
The input raster is supposed to
represent the location of point, line, or polygon infrastructure
(e.g. houses, roads, mining areas), but any landscape variable whose
representation might be one of those would fit here
(e.g. areas of forest or any other habitat type or land cover).
We recommend that the input raster has a metric projection, so that distances
and zones of influence are based on distance to infrastructure measured in meters.
}
\examples{
# Running calc_zoi_nearest through R
library(terra)
library(sf)

# Load raster data
f <- system.file("raster/sample_area_cabins.tif", package = "oneimpact")
cabins <- terra::rast(f)

# Load vector data
f2 <- system.file("vector/sample_area_cabins.gpkg", package = "oneimpact")
cabins_vect <- sf::st_read(f2)

# calculate distance to the nearest feature
d <- calc_zoi_nearest(cabins, type = "euclidean")
plot(d)

# calculate log_dist (the rest is equal)
log_d <- calc_zoi_nearest(cabins, type = "log", log_base = 10)
plot(log_d)

# calculate sqrt_dist
sqrt_d <- calc_zoi_nearest(cabins, type = "sqrt")
plot(sqrt_d)

# calculate exponential decay zone of influence
# using exp_decay_parms parameter
exp_d1 <- calc_zoi_nearest(cabins, type = "exp_decay",
                           intercept = 1, lambda = 0.001)
plot(exp_d1)

# calculate exponential decay zone of influence using
# radius and zoi_limit (default)
radius2 <- 1000 # zoi = 1000m
zoi_limit2 <- 0.05 # here zoi is the distance where the function reaches 0.05
exp_d2 <- calc_zoi_nearest(cabins, type = "exp_decay", radius = radius2,
                           zoi_limit = zoi_limit2)
plot(exp_d2)
# buffer
# zoi = 1000m
cabins_vect |>
  sf::st_buffer(dist = radius2) |>
  sf::st_union() |>
  plot(add = T, border = "black")
legend("bottomright", legend = c("ZoI radius"), col = c("black"), lwd = 1.1)

# calculate exponential decay zone of influence using half life parameter
# if half_life = 250 m and zoi_hl_ratio = 4, zoi is 1000 m
half_life3 <- 250 # intensity gets down to 1/16 = 0.06 for 4*half_life=1000m
zoi_hl_ratio3 <- 4 # default
exp_d4 <- calc_zoi_nearest(cabins, type = "exp_decay", half_life = half_life3,
                           zoi_hl_ratio = zoi_hl_ratio3)
plot(exp_d4)
# buffer
cabins_vect |>
  sf::st_buffer(dist = half_life3) |>
  sf::st_union() |>
  plot(add = T, border = "red")
# zoi = 1000m
cabins_vect |>
  sf::st_buffer(dist = half_life3*zoi_hl_ratio3) |>
  sf::st_union() |>
  plot(add = T, border = "black")
legend("bottomright", legend = c("Exponential half-life", "ZoI radius"),
       col = c("red", "black"), lwd = 1.1)

# calculate exponential decay zone of influence using
# radius parameter and zoi_hl_ratio
radius4 <- 4000 # intensity gets down to 1/16 = 0.06 for zoi = 4000m, half_life = 1000m
zoi_hl_ratio4 <- 6 # default
exp_d4 <- calc_zoi_nearest(cabins, type = "exp_decay", radius = radius4,
                           zoi_hl_ratio = zoi_hl_ratio4)
plot(exp_d4)
# buffer
# half_life = 1000m
cabins_vect |>
  sf::st_buffer(dist = radius4/zoi_hl_ratio4) |>
  sf::st_union() |>
  plot(add = T, border = "red")
# zoi = 4000m
cabins_vect |>
  sf::st_buffer(dist = radius4) |>
  sf::st_union() |>
  plot(add = T, border = "black", )
legend("bottomright", legend = c("Exponential half-life", "ZoI radius"),
       col = c("red", "black"), lwd = 1.1)

#---
# bartlett influence, ZOI = 1000m
bart_d <- calc_zoi_nearest(cabins, type = "bartlett", radius = 1000)
plot(bart_d)

# buffer 1000m
cabins_vect |>
  sf::st_buffer(dist = 1000) |>
  sf::st_union() |>
  plot(add = T, border = "black")
legend("bottomright", legend = c("Bartlett ZoI 1000m"),
       col = c("black"), lwd = 1.1)

# calculate threshold influence, ZoI = 1000m
d <- calc_zoi_nearest(cabins, type = "threshold", radius = 1000)
plot(d)

# Gaussian decay influence, ZoI = 1000m
g_d <- calc_zoi_nearest(cabins, type = "Gauss", radius = 1000)
plot(g_d)

# buffer 1000m
cabins_vect |>
  sf::st_buffer(dist = 1000) |>
  sf::st_union() |>
  plot(add = T, border = "black")
legend("bottomright", legend = c("Gaussian ZoI 1000m"),
       col = c("black"), lwd = 1.1)

#--------------------
# Running calc_zoi_nearest through GRASS GIS
library(rgrass7)
library(terra)

# Load raster data
f <- system.file("raster/sample_area_cabins.tif", package = "oneimpact")
cabins <- terra::rast(f)

# connect to grass gis 7.8 and create grass location
# For linux or within OSGeo4W shell
grassdir <- system("grass78 --config path", intern = TRUE)
# If you used the standalone installer in Windows
# grassdir <- "C:\\Programs\\GRASS GIS 7.8" # Correct if the path is different

gisDB <- "." # create location and mapset in the working directory
loc <- "ETRS_33N/" # name of the location
ms <- "PERMANENT" # name of the mapset
rgrass7::initGRASS(gisBase = grassdir,
                   SG = cabins, # use map to define location projection
                   home = tempdir(),
                   override = TRUE,
                   gisDbase = gisDB,
                   location = loc,
                   mapset = ms)

# define map name within GRASS GIS
cabins_g <- "cabins_example"
# add file to GRASS GIS mapset
rgrass7::write_RAST(cabins, cabins_g, flags = c("overwrite", "o"))

# check
terra::plot(cabins, col = "black",
            main = "Map of tourist cabins")

#---
# define region in GRASS GIS
rgrass7::execGRASS("g.region", raster = cabins_g,
                   flags = "p")

# Input map name within GRASS GIS
cabins_g

# Exponential decay ZoI=1000m
expdecay_name <- calc_zoi_nearest(cabins_g, type = "exp_decay",
                                  radius = 1000,
                                  where = "GRASS",
                                  g_verbose = FALSE, g_overwrite = TRUE)

# Bartlett decay ZoI=1000m
bartlett_name <- calc_zoi_nearest(cabins_g, type = "bartlett",
                                  radius = 1000,
                                  where = "GRASS", g_verbose = FALSE, g_overwrite = TRUE)

# Threshold influence ZoI = 1000m
threshold_name <- calc_zoi_nearest(cabins_g, type = "threshold",
                                   radius = 1000,
                                   where = "GRASS", g_verbose = FALSE, g_overwrite = TRUE)

# Gaussian influence ZoI = 1000m
gaussian_name <- calc_zoi_nearest(cabins_g, type = "Gauss",
                                  radius = 1000,
                                  where = "GRASS", g_verbose = FALSE, g_overwrite = TRUE)

# Log-distance
log_name <- calc_zoi_nearest(cabins_g, type = "log", log_base = 10,
                             where = "GRASS",
                             g_verbose = FALSE, g_overwrite = TRUE)

# Euclidean
euclidean_name <- calc_zoi_nearest(cabins_g, type = "euclidean",
                                   where = "GRASS",
                                   g_verbose = FALSE, g_overwrite = TRUE)

(all_names <- c(euclidean_name, log_name, expdecay_name,
                bartlett_name, threshold_name, gaussian_name))

# visualize
cabins_zoi_nearest <- rgrass7::read_RAST(all_names, return_format = "terra")

title_plot <- c("Euclidean distance", "Log distance (base 10)",
                "Exponential ZoI 1000m", "Bartlett ZoI 1000m",
                "Threshold ZoI 1000m", "Gaussian ZoI 1000m")
terra::plot(cabins_zoi_nearest, main = title_plot)

# remove rasters created
# to_remove_rast <- c(all_names)
# rgrass7::execGRASS("g.remove", type = "rast", name = to_remove_rast, flags = "f")
}
\seealso{
See \code{\link[=zoi_functions]{zoi_functions()}} for some ZoI function shapes. \cr
See also \code{\link[terra:distance]{terra::distance()}} for details on the calculation of the distance
to the nearest future in R. \cr
See
\href{https://grass.osgeo.org/grass80/manuals/r.mfilter.html}{r.grow.distance},
for details on the calculation of the distance to the nearest future in GRASS. \cr
See \code{\link[=calc_zoi_cumulative]{calc_zoi_cumulative()}} for the computation of the cumulative
zone of influence and density of multiple features.
}
