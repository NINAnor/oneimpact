% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulate_dist_dens.R
\name{simulate_dist_dens}
\alias{simulate_dist_dens}
\title{Simulate landscapes with features and calculate distance and densities of features}
\usage{
simulate_dist_dens(
  n_features = 1000,
  centers = 1,
  width = 0.05,
  res = 0.1,
  extent_x = c(0, 1),
  extent_y = c(0, 1),
  buffer_around = 0,
  transform_dist = NULL,
  log_base = exp(1),
  dist_offset = 1,
  type_density = c("Gauss", "circle", "rectangle")[1],
  scale = 100,
  extent_x_cut = extent_x,
  extent_y_cut = extent_y
)
}
\arguments{
\item{n_features}{\verb{[integer(1)=1000]} \cr Total number of features to spread in space.}

\item{centers}{\verb{[integer(1)=1]} \cr Number of centers around which the features will be placed.
Used only if \code{method = "mobsim"}.}

\item{width}{\verb{[numeric(1)=0.05]} \cr Radius of the "patches" of features, around the "patch" centers.
Used only if \code{method = "mobsim"}.}

\item{res}{\verb{[numeric(1)=0.1]} \cr Resolution of the output raster.}

\item{extent_x}{\verb{[numeric vector(2)=c(0,1)]} \cr Vector representing the minimum and
maximum extent in x and y within which the points should be placed, in the format c(min,max).}

\item{buffer_around}{\verb{[numeric(1)=0.1]} \cr Size of the buffer around the extent of the landscape,
to avoid edge effects when calculating densities using neighborhood analysis.}

\item{transform_dist}{\verb{[character(1)=NULL]\{"log","sqrt", "exp_decay", "bartlett\}} \cr
By default, NULL - distances are no transformed. If \code{log}, the distances are
log-transformed. If \code{sqrt}, the output is \code{sqrt(distance)}. If \code{exp_decay}, the exponential
decay distance is calculated. If \code{bartlett}, a triangular tent-shaped decay distance is returned.
See details below.
Other options still to be implemented.}

\item{log_base}{\verb{[numeric(1)=exp(1)]} \cr Base of the logarithm, if \code{transform_dist = log}.}

\item{dist_offset}{\verb{[numeric(1)=1]} \cr Number to add to distance before transforming it,
to avoid \code{-Inf}/\code{Inf} values (e.g. in the case of log). It should be a very small value compared to the
range of values of distance.}

\item{type_density}{\verb{[character(1)="Gauss"]\{"Gauss", "circle", "rectangle"\}} \cr
Type of filter used to calculate density. See description for details.}

\item{scale}{\verb{[numeric(1)=100]} \cr Scale of the neighborhood analysis, used to calculate densities.
It can be a single value of a vector of values, in which case several density maps (for each scale)
are created.}

\item{extent_x_cut}{\verb{[numeric vector(2)=c(0,1)]} \cr Vectors representing the minimum and
maximum extent in x and y for the final output, in the format c(min,max). The default is to
keep the same extent of the input raster.}
}
\value{
A RasterBrick with de distance to the nearest feature and the densities for all scales selected.
}
\description{
This function is a combination of \code{\link[=set_points]{set_points()}} and \code{\link[=calc_dist_dens]{calc_dist_dens()}}, to simulate
a point pattern representing the distribution of point-type infrastructure in
space, rasterize it, and calculate the distance to and density of infrastructure.
}
\details{
The function builds upon the function \code{\link[mobsim:sim_thomas_community]{mobsim::sim_thomas_community()}} from the \link{mobsim}
package. Originally the function is intended to simulate positions of multiple
species in the context of species abundance distribution studies, but it fits
well in case of a single species (or point patterns for a single type of feature).

TO IMPROVE: implement rasterization with \link{terra} package
}
\examples{
library(mobsim)
library(raster)

set.seed(1234)

# multiple focii
ext <- 30000
wd <- 0.1*ext
scales <- c(250, 500, 1000, 2500, 5000)/2
rasts <- simulate_dist_dens(n_features = 1000, centers = 5,
                            width = wd, res = 100,
                            extent_x = c(0, ext), extent_y = c(0, ext),
                            buffer_around = 10000,
                            type_density = "Gauss", scale = scales,
                            extent_x_cut = c(0, ext), extent_y_cut = c(0, ext))
plot(rasts)
}
