% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grass_binarize.R
\name{grass_binarize}
\alias{grass_binarize}
\title{Binarize continuous raster maps}
\usage{
grass_binarize(
  x,
  breaks = 0.5,
  output = paste0(x, "_bin"),
  null = NULL,
  setnull = NULL,
  bin_values = c(0, 1),
  quiet = TRUE,
  overwrite = FALSE,
  ...
)
}
\arguments{
\item{x}{\verb{[character(1)]} \cr Name of the input raster map, within a GRASS GIS location and mapset.}

\item{breaks}{\verb{[numeric]} \cr Breaks or threshold to define the binary values in the output
binary map. All pixels with \code{value >= breaks} are considered as 1 (or the upper value defined in
\code{bin_values}), and all the rest are considered as 0 (or the lower value defined in \code{bin_values}).
\code{breaks} might be either a single numeric value or a vector of numeric values, in which case
multiple binary maps are created (with different break thresholds).}

\item{output}{\verb{[character(1)]} \cr Name of the output map, or prefix of the output map if
\code{length(breaks) > 1}. In the latter case, the names are completed with the break value.
The defult is to use the same name as the input map, plus "_bin" in the end.}

\item{null}{\verb{[numeric(1)=NULL]} \cr If \code{NULL} (default), all NULL/no-data pixels in from \code{x}
are kept as they are in the output map. Otherwise, a numeric value that all NULL pixels should
assume in the output map. It uses the module
\href{https://grass.osgeo.org/grass78/manuals/r.null.html}{r.null}).}

\item{setnull}{\verb{[]} \cr If \code{NULL} (default), no changes are made. Otherwise, a set of numeric
values that should be transformed into NULL/NA data (using the module
\href{https://grass.osgeo.org/grass78/manuals/r.null.html}{r.null}).}

\item{bin_values}{\verb{[numeric(2)=c(0,1)]} \cr Values c(lower, upper) that the output map pixels should
have if their values are either "lower" or "equal or higher" \code{breaks}. By default, c(0, 1).}

\item{quiet, overwrite}{\verb{[logical(1)]} \cr Whether the procedures is GRASS GIS should be run
quetly (flag \code{quiet = TRUE}) and whether the output maps should be overwriten (flag \code{overwrite = TRUE}).}
}
\value{
A binarized map with only two values (or a set of binarized maps if \code{length(breaks)} > 1).
}
\description{
Through GRASS GIS, this function transforms continuous
or categorical maps (with more than 1 category)
into binary maps (with only two values), to represent, e.g.,
habitat-matrix maps in the context of landscape ecology. It can
also be used to produce binary maps form maps with only one category (and
all the rest as NULL/no-data). It requires an active connection between
the R session and a GRASS GIS location and mapset
(through the package \link{rgrass7}), and that the input map is already loaded
within this GRASS GIS mapset.
}
\details{
For a similar procedure within R, use the function \code{\link[landscapetools:util_binarize]{landscapetools::util_binarize()}}
or the raster algebra functions within the \link{raster} and \link{terra} packages.
}
\examples{
# libraries
library(rgrass7)
library(raster)
library(terra)
library(dplyr)

# connect to grass gis 7.8
grassdir <- system("grass78 --config path", intern = T)
gisDB <- "/data/grass"
loc <- "ETRS_33N/"
ms <- "u_bb_cuminf"
rgrass7::initGRASS(gisBase = grassdir,
                   home = tempdir(),
                   override = T,
                   gisDbase = gisDB,
                   location = loc,
                   mapset = ms)

# input map (not binarized)
rgrass7::use_sp()
name_var <- "private_cabins_sub"

# binarize the input map

# map with only 1
cabins_bin1_name <- grass_binarize(name_var, output = "cabins_bin1",
                                   breaks = 1, overwrite = T)
# map with 0, 1
cabins_bin2_name <- grass_binarize(name_var, output = "cabins_bin2",
                                   breaks = 1, null = 0, overwrite = T)

# visualize
cabins_bin1_2 <- rgrass7::readRAST(c(cabins_bin2_name, cabins_bin1_name)) \%>\%
  raster::stack() \%>\%
  terra::rast()
plot(cabins_bin1_2, main = c("Binarized map setting null to 0", "Binarized map keeping null"))

# binarize the map with multiple break values

# first create a continuous map
cont_map_name <- calc_influence_nearest(name_var, zoi = 1000, transform = "exp_decay",
                                        where = "GRASS", overwrite = T)
# binarize
cabins_bin2vals_name <- grass_binarize(cont_map_name, output = "cabins_bin",
                                       breaks = c(0.3, 0.5), overwrite = T)
# visualize
cabins_bin2vals <- rgrass7::readRAST(c(cont_map_name, cabins_bin2vals_name)) \%>\%
  raster::stack() \%>\%
  terra::rast()
plot(cabins_bin2vals,
     main = c("Original map",
              "Binarized map, break = 0.3",
              "Binarized map, break = 0.5"))
}
\seealso{
See also \code{\link[landscapetools:util_binarize]{landscapetools::util_binarize()}}, \code{\link[landscapetools:util_classify]{landscapetools::util_classify()}},
and a documentation of raster algebra with \link{terra} \href{https://rspatial.org/terra/pkg/4-algebra.html}{here} and with
\link{raster} \href{https://rspatial.org/raster/pkg/4-algebra.html}{here}.
}
