% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grass_binarize.R
\name{grass_binarize}
\alias{grass_binarize}
\title{Binarize continuous raster maps}
\usage{
grass_binarize(
  x,
  breaks = 0.5,
  output = paste0(x, "_bin"),
  null = NULL,
  setnull = NULL,
  bin_values = c(0, 1),
  input_as_region = FALSE,
  verbose = FALSE,
  overwrite = FALSE,
  ...
)
}
\arguments{
\item{x}{\verb{[character(1)]} \cr Name of the input raster map, within a GRASS GIS location and mapset.}

\item{breaks}{\verb{[numeric]} \cr Breaks or threshold to define the binary values in the output
binary map. All pixels with \code{value >= breaks} are considered as 1 (or the upper value defined in
\code{bin_values}), and all the rest are considered as 0 (or the lower value defined in \code{bin_values}).
\code{breaks} might be either a single numeric value or a vector of numeric values, in which case
multiple binary maps are created (with different break thresholds).}

\item{output}{\verb{[character(1)]} \cr Name of the output map, or prefix of the output map if
\code{length(breaks) > 1}. In the latter case, the names are completed with the break value.
The defult is to use the same name as the input map, plus "_bin" in the end.}

\item{null}{\verb{[numeric(1)=NULL]} \cr If \code{NULL} (default), all NULL/no-data pixels in from \code{x}
are kept as they are in the output map. Otherwise, a numeric value that all NULL pixels should
assume in the output map. It uses the module
\href{https://grass.osgeo.org/grass78/manuals/r.null.html}{r.null}).}

\item{setnull}{\verb{[]} \cr If \code{NULL} (default), no changes are made. Otherwise, a set of numeric
values that should be transformed into NULL/NA data (using the module
\href{https://grass.osgeo.org/grass78/manuals/r.null.html}{r.null}).}

\item{bin_values}{\verb{[numeric(2)=c(0,1)]} \cr Values c(lower, upper) that the output map pixels should
have if their values are either "lower" or "equal or higher" \code{breaks}. By default, c(0, 1).}

\item{input_as_region}{\verb{[logical(1)=FALSE]} \cr Should the input map \code{x} be
used to redefine the working region in GRASS before raster binarization?
If \code{TRUE}, \code{x} is used to define the region with \code{g.region}. If \code{FALSE},
the region previously defined in the GRASS GIS session is used for computation.
Default is \code{FALSE}.}

\item{verbose}{\verb{[logical(1)=FALSE]} \cr Should messages of the computation steps
be printed in the prompt along the computation?}

\item{overwrite}{\verb{[logical(1)]} \cr Whether the output maps should be overwriten
(flag \code{overwrite = TRUE}).}
}
\value{
A binarized map with only two values (or a set of binarized maps if \code{length(breaks)} > 1)
within the GRASS GIS mapset. In R, the output is a string with the name of this
map.
}
\description{
Through GRASS GIS, this function transforms continuous
or categorical maps (with more than 1 category)
into binary maps (with only two values), to represent, e.g.,
habitat-matrix maps in the context of landscape ecology. It can
also be used to produce binary maps form maps with only one category (and
all the rest as NULL/no-data). It requires an active connection between
the R session and a GRASS GIS location and mapset
(through the package \link{rgrass}), and that the input map is already loaded
within this GRASS GIS mapset.
}
\details{
For a similar procedure within R, use raster algebra functions within the \link{raster} and \link{terra} packages.
}
\examples{
# libraries
library(rgrass)
library(terra)

# Load raster data
f <- system.file("raster/sample_area_cabins.tif", package = "oneimpact")
cabins <- terra::rast(f)

# connect to grass gis and create grass location
# For linux or within OSGeo4W shell
grassdir <- system("grass --config path", intern = TRUE)
# grassdir <- system("grass78 --config path", intern = TRUE) # for GRASS 7.8
# If you used the standalone installer in Windows
# grassdir <- "C:\\Programs\\GRASS GIS 7.8" # Correct if the path GRASS version or path is different

gisDB <- "." # create location and mapset in the working directory
loc <- "ETRS_33N/" # name of the location
ms <- "PERMANENT" # name of the mapset
rgrass::initGRASS(gisBase = grassdir,
                  SG = cabins, # use map to define location projection
                  home = tempdir(),
                  override = TRUE,
                  gisDbase = gisDB,
                  location = loc,
                  mapset = ms)

# add map to GRASS
rgrass::write_RAST(cabins, "cabins", flags = "o")

# binarize the input map

# map with only 1
cabins_bin1_name <- grass_binarize("cabins", output = "cabins_bin1",
                                   breaks = 1, overwrite = T)
# map with 0, 1
cabins_bin2_name <- grass_binarize("cabins", output = "cabins_bin2",
                                   breaks = 1, null = 0, overwrite = T)

# visualize
cabins_bin1_2 <- rgrass::read_RAST(c(cabins_bin1_name, cabins_bin2_name),
                                   return_format = "terra", NODATA = 255)
plot(cabins_bin1_2, main = c("Binarized map keeping null", "Binarized map setting null to 0"))

#-------
# binarize the map with multiple break values

# first create a continuous map
cont_map_name <- calc_zoi_nearest("cabins_bin1", radius = 1000,
                                  type = "exp_decay",
                                  where = "GRASS", overwrite = TRUE)
# binarize
cabins_bin2vals_name <- grass_binarize(cont_map_name, output = "cabins_zoi1000_bin",
                                       breaks = c(0.3, 0.8), overwrite = T)
# visualize
cabins_bin2vals <- rgrass::read_RAST(c(cont_map_name, cabins_bin2vals_name),
                                     return_format = "terra", NODATA = 255)
plot(cabins_bin2vals,
     main = c("Original map",
              "Binarized map, break = 0.3",
              "Binarized map, break = 0.8"))
}
\seealso{
See also the documentation of raster algebra with \link{terra} \href{https://rspatial.org/terra/pkg/4-algebra.html}{here}
and with \link{raster} \href{https://rspatial.org/raster/pkg/4-algebra.html}{here}.
}
