% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calc_zoi_cumulative.R
\name{calc_zoi_cumulative}
\alias{calc_zoi_cumulative}
\title{Calculate the cumulative zone of influence of multiple features}
\usage{
calc_zoi_cumulative(
  x,
  radius = 100,
  type = c("circle", "Gauss", "rectangle", "exp_decay", "bartlett", "threshold",
    "mfilter")[1],
  where = c("R", "GRASS")[1],
  output_type = c("cumulative_zoi", "density")[1],
  zoi_limit = 0.05,
  min_intensity = 0.01,
  max_dist = 50000,
  zeroAsNA = FALSE,
  extent_x_cut = NULL,
  extent_y_cut = NULL,
  na.policy = "omit",
  na.rm = TRUE,
  g_module = c("r.mfilter", "r.resamp.filter", "r.neighbors")[1],
  g_output_map_name = NULL,
  g_input_as_region = FALSE,
  g_remove_intermediate = TRUE,
  g_overwrite = FALSE,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{x}{\verb{[RasterLayer,SpatRaster,character]} \cr Raster representing
locations of features, preferentially with positive values where the features
are located (or counts of features within a pixel) and 0 elsewhere.
Alternatively, \code{x} might be a binary (dummy) spatial variable representing
the presence of linear or area features, with zero as background.
\code{x} can be a \code{RasterLayer} from \link{raster} package or a \link{SpatRaster} from
\link{terra} package. If \code{where = "GRASS"}, \code{x} must be a string corresponding
to the name of the input map within a GRASS GIS location and mapset.
Continuous or discrete raster maps with multiple categories can be binarized
to be used as input for \code{calc_zoi_cumulative()} through
\code{\link[landscapetools:util_binarize]{landscapetools::util_binarize()}} in R or \code{\link[=grass_binarize]{grass_binarize()}}
in GRASS GIS, or through common raster algebra in both
environments.

Notice that, different from \code{\link[=calc_zoi_nearest]{calc_zoi_nearest()}}, the input maps \code{x}
must have zero as background values, instead of NA. In R it is possible to
account for NA background values by setting \code{zeroAsNA = TRUE} for the computation
of the cumulative ZoI.
In GRASS, maps without NA as background might be changed into maps with 0 as
background to be used in  \code{calc_zoi_cumulative()}
through \href{https://grass.osgeo.org/grass78/manuals/r.mapcalc.html}{raster algebra}
and e.g. through the use of the module
\href{https://grass.osgeo.org/grass80/manuals/r.null.html}{\code{r.null}}.}

\item{radius}{\verb{[numeric(1)=100]} \cr Radius or scale of the moving
window for neighborhood analysis, used to calculate the cumulative zoi and
density. The radius represent
the distance at which the ZoI vanishes or goes below a given minimum limit value
\code{zoi_limit}. It can be a single value or a vector of values, in which case
several cumulative ZoI or density maps (one for each radius) are created.
For \code{type = "circle"}, the \code{radius} corresponds to the radius of the
circle filter. For \code{type = "Gauss"} and \code{type = "exp_decay"}, \code{radius}
corresponds to the distance where the Gaussian or exponential decay function
decrease or a small \code{zoi_limit} value. If \code{type = "bartlett"}, \code{radius}
is the distance at which the filter reaches zero, after a linear decay
from the central pixel. If \code{type = "rectangle"}, \code{radius}
corresponds to half the size of the side of a square filter.
If \code{type = "mfilter"}, radius is not a numeric value but a matrix itself,
defined by the user. See description in the details and \code{\link[=zoi_functions]{zoi_functions()}}
for more details on the zone of influence function shapes and parameters.}

\item{type}{\verb{[character(1)="circle"]\{"circle", "Gauss", "rectangle", "exp_decay", "bartlett", "threshold", "step", "mfilter"\}} \cr
Type of filter (shape of the zone of influence) used to calculate the
cumulative ZoI or density. See details.}

\item{where}{\verb{[character(1)="R"]\{"R", "GRASS"\}} \cr Where should the
computation be done? Default is \code{"R"}. If \code{where = "GRASS"}, the R session
must be linked to an open GRASS GIS session in a specific location and mapset.}

\item{output_type}{\verb{[character(1)="cumulative_zoi"]\{"cumulative_zoi", "density"\}} \cr If \code{output_type = "cumulative_zoi"} (default), the ZoI weight
matrix not not normalized, i.e. the maximum value of the weight matrix at the
central pixel value is always 1. This means the values of the input map are
summed (considering a decay with distance within the neighborhood) and the
output map presents values higher than 1. If \code{output_type = "density"}, the
weight matrix is normalized before the filtering process, leading to values
in the outmap map generally lower than 1.}

\item{zoi_limit}{\verb{[numeric(1)=0.05]} \cr For non-vanishing functions
(e.g. \code{exp_decay}, \code{gaussian_decay}), this value is used to set the relationship
between the ZoI radius and the decay functions:
\code{radius} is defined as the minimum distance at which the ZoI assumes values
below \code{zoi_limit}. The default is 0.05. This parameter is used only
if \code{radius} is not \code{NULL}.}

\item{min_intensity}{\verb{[numeric(1)=0.01]} \cr Minimum intensity of the
exponential and Gaussian decay functions to
define the radius of the window that define the filter. See
\code{\link[=filter_create]{filter_create()}} for details.}

\item{max_dist}{\verb{[numeric(1)=50000]} \cr Maximum size (in meters) to
define the radius of the window that defines the filter. Only
applicable for exponential and Gaussian decay functions. See
\code{\link[=filter_create]{filter_create()}} for details.}

\item{zeroAsNA}{\verb{[logical(1)=FALSE]} \cr If \code{TRUE} treats cells that are
\code{NA} as if they were zero.}

\item{extent_x_cut, entent_y_cut}{\verb{[numeric vector(2)=c(0,1)]} \cr Vector
representing the minimum and
maximum extent in x and y for the final output, in the format c(min,max).
It is intended to keep only a region of interest but consider the
surroundings when calculating the cumulative ZoI or density. This might be
especially useful for example in the use of the \code{r.mfilter} algorithm in
GRASS, in which the edges of the region are excluded from the computation.
The default is to keep the same extent of the input raster.}

\item{na.policy}{\verb{[character(1)="omit"] \\cr Can be used to determine the cells of }x\verb{for which focal values should be computed. Must be one of "all" (compute for all cells), "only" (only for cells that are NA) or "omit" (skip cells that are NA). Note that the value of this argument does not affect which cells around each focal cell are included in the computations (use na.rm=TRUE to ignore cells that are NA for that). See [terra::focal()] for details. Only used when}where = "R"`.}

\item{na.rm}{\verb{[logical(1)=FALSE]} \cr Should missing values be removed for
filtering calculations? Option for the neighborhood analysis performed
through the \code{\link[terra:focal]{terra::focal()}} function. Only used when \code{where = "R"}.}

\item{g_module}{\verb{[character(1)="r.mfilter"]\{"r.mfilter", "r.resamp.filter", "r.neighbors"\}} \cr
If \code{where = "GRASS"}, which algorithm should be used to compute the cumulative
ZoI? See details for their description.}

\item{g_output_map_name}{\verb{[character(1)=NULL]} \cr Name of the output map. Only
used when \code{where = "GRASS"}. If \code{NULL} (default), a standard name is created
based on the name of the input map \code{x}, the ZoI shape \code{type}, and the ZoI
radius \code{radius}.}

\item{g_input_as_region}{\verb{[logical(1)=TRUE]} \cr Should the input map \code{x} be
used to redefine the working GRASS region before cumulative ZoI calculation?
If \code{TRUE}, \code{x} is used to define the region with \code{g.region}. If \code{FALSE},
the region previously defined in the GRASS GIS session is used for computation.}

\item{g_remove_intermediate}{\verb{[logical(1)=TRUE]} \cr Should the intermediate
maps created for computing the output map be excluded in the end of the
process? Only used when \code{where = "GRASS"}.}

\item{g_overwrite}{\verb{[logical(1)=FALSE]} \cr If the a map already exists with the
name \code{g_output_map_name} in the working GRASS GIS location and mapset, should
it be overwritten? Only used when \code{where = "GRASS"}.}

\item{verbose}{\verb{[logical(1)=FALSE]} \cr Should messages of the computation steps
be printed in the prompt along the computation?}

\item{...}{Other arguments to be used within \code{\link[=filter_create]{filter_create()}}
or \code{\link[terra:focal]{terra::focal()}}.}
}
\value{
A \code{RasterLayer} or \link{SpatRaster} (according to the input \code{x} map)
with the cumulative zone of influence or density of features. While the
cumulative ZoI uses a ZoI/weight matrix rescaled to 1 at the central pixel
(creating values in the output map which might go well beyond 1), the
density of features uses a normalized ZoI/weight matrix (with all values
summing 1), what created values smaller than one in the output map.
if multiple \code{radius} values are given, a \code{RasterBrick} or multi-layer
\code{SpatRaster}, with the cumulative ZoI or density maps for each ZoI radius. \cr
If the computation is done in GRASS GIS, the output is name of
the output raster map within the GRASS GIS location and mapset of the
current session. The user can retrieve these maps to R using
\code{\link[rgrass7:readRAST]{rgrass7::read_RAST()}} or export them outside GRASS using the
\code{r.out.gdal} module, for instance.
}
\description{
This function takes in a raster with locations or counts of
infrastructure
and calculates a raster (or set of rasters, in case there is more the one
value for \code{radius}) representing the cumulative zone of influence (ZoI)
or density of features in space. The process is done through a spatial
filter/moving window/neighborhood analysis. The zones of influence
(or weight matrices) are defined by functions that decay with the distance
from each infrastructure feature and their rate of decay is controlled by the
ZoI radius (\code{radius}), which defines how far the influence of an infrastructure
feature goes. By using moving window analyses, the cumulative ZoI account for
the sum of the influence of multiple features across space, weighted by
the distance to these features according the the ZoI shape.
For more details on the ZoI functions, see \code{\link[=zoi_functions]{zoi_functions()}}.

The procedure might be computed in both R and GRASS GIS. In R, the
neighborhood analysis is done with the \code{\link[terra:focal]{terra::focal()}} function. In GRASS,
different modules might be used for the computation: \code{r.resamp.filter},
\code{r.mfilter}, or \code{r.neighbors}. See details for their differences. In GRASS, it
requires an active connection between the R session and a GRASS GIS
location and mapset (through the package \link{rgrass7}), and that the input
maps are already loaded within this GRASS GIS mapset.
If the calculations are done in R, the input is a (set of) raster map(s)
and the function returns another (set of) raster map(s). If the calculations
are done within GRASS GIS, the input is the name of a raster map already
loaded in a GRASS GIS location and mapset, and the function returns
only the name of the output map. This map is stored in the the GRASS GIS
location/mapset, and might be retrieved to R through the
\code{\link[rgrass7:readRAST]{rgrass7::read_RAST()}} function or exported outside GRASS using the
\code{r.out.gdal} module, for instance.
}
\section{Details}{
The input raster is supposed to
represent the location of point, line, or polygon infrastructure
(e.g. houses, roads, mining areas), but any landscape variable whose
representation might be one of those would fit here
(e.g. areas of forest or any other habitat type or land cover).
We recommend that the input raster has a metric projection, so that distances
and zones of influence are based on distance to infrastructure measured in meters.
\subsection{Zone of Influence functions and weight matrices}{

The neighborhood analysis to define the cumulative ZoI can be
computed with different functions/filters. The options currently implemented
are:
\itemize{
\item circular/threshold matrix: the circular filter (\code{type = "circle"} or
\code{type = "threshold"} or \code{type = "step"}) is a matrix with constant weights
in which the parameter \code{radius} corresponds to the radius of the circle
centered on the central pixel. It is similar to a circular buffer matrix.
\item Gaussian matrix: the Gaussian filter (\code{type = "Gauss"} or \code{type = "gauss"}
or \code{type = "gaussian_decay"}) is a matrix with weights following a Gaussian
or Normal decay. The Gaussian curve is 1 at the central cell and
is parameterized on the \code{radius} and
the \code{zoi_limit}, which controls how fast the curve decreases with distance.
See \code{\link[=zoi_functions]{zoi_functions()}} for details.
\item Exponential decay matrix: the exponential decay filter
(\code{type = "exp_decay"}) is a matrix with weights following an exponential
decay curve, with value 1 in the central cell and
parameterized on the \code{radius} and the \code{zoi_limit}.
See \code{\link[=zoi_functions]{zoi_functions()}} for details.
\item Rectangular matrix: the rectangular filter (\code{type = "rectangle"}
or \code{type = "box"}) is
a weight matrix whose shape is a square of dimensions \eqn{n} x \eqn{n},
with \eqn{n = 2 * radius}.
\item Bartlett or linear decay matrix: the Bartlett, linear, or tent decay filter
(\code{type = "bartlett"} or \code{type = "linear_decay"} or \code{type = "tent_decay"})
is a weight matrix whose value is 1 in the central cell and whose weights
decrease linearly up to zero at a distance equals \code{radius}.
See \code{\link[=zoi_functions]{zoi_functions()}} for details.
\item user-customized filter: if \code{type = "mfilter"}, \code{radius} is not
numeric but should be a user-defined matrix of weights. Examples are ones
created through \code{\link[=filter_create]{filter_create()}}, \code{\link[terra:focalMat]{terra::focalMat()}},
\code{\link[smoothie:kernel2dmeitsjer]{smoothie::kernel2dmeitsjer()}}, or matrices created by hand.
}

Weight matrices might differ from the expected decay function depending on
the intended resolution - the finer the resolution, the more detailed and
correspondent to the original functions the matrix will be.
}

\subsection{Algorithms in GRASS GIS}{

In GRASS GIS, different modules might be used for the computation,
\code{r.resamp.filter}, \code{r.mfilter}, or \code{r.neighbors}. The module to be used is
controlled by the parameter \code{g_module}. These algorithms provide different
capabilities and flexibility.
\itemize{
\item \code{r.resamp.filter} seems to be the fastest one
in most cases, but has less flexibility in the choice of the zone of influence
function. The algorithm calculates the weighted density of features, which
might be rescaled to the cumulative ZoI if the appropriate scaling factor
(calculated from the weight matrix) is provided. Currently only the
filters \code{type = "bartlett"} and \code{type = "box"} are implemented. More
information about the algorithm
\href{https://grass.osgeo.org/grass80/manuals/r.resamp.filter.html}{here}.
\item \code{r.mfilter} is slower than \code{r.resamp.filter} but much faster than
\code{r.neighbors}, and allow a flexible choice of the shape of the zone of
influence (the wight matrix shape). \code{r.mfilter} is then the most indicated
in terms of a balance between flexibility in the choice of the ZoI shape
and computation efficiency.
The only inconvenient of \code{r.mfilter} is that it
creates an edge effect with no information in the outer cells of a raster
(the number of cells correspond to \code{radius} or half the size of the weight
matrix), so if it is used the users should add a buffer area
\eqn{ge radius} around the input raster map, to avoid such edge effects.
See \url{https://github.com/OSGeo/grass/issues/2184} for more details.
\item \code{r.neighbors} is considerably slower than the other algorithms (from 10 to
100 times), but allow the a flexible choice of the ZoI shape. Contrary to
\code{r.resamp.filter} and \code{r.mfilter}, which can only perform a sum of pixel
values weighted by the input filter or ZoI, \code{r.neighbors} might
calculate many other statistical summaries within the window of analysis,
such as mean, median, standard deviation etc.
}
}
}

\examples{
# Running calc_zoi_cumulative through R
library(terra)

# Load raster data
f <- system.file("raster/cabins_count.tif", package = "oneimpact")
cabins <- terra::rast(f)

# calculate cumulative zone of influence for multiple influence radii,
# using a Gaussian filter
zoi_values <- c(250, 500, 1000, 2500, 5000)
cumzoi_gauss <- calc_zoi_cumulative(cabins, type = "Gauss", radius = zoi_values)
plot(cumzoi_gauss)

# calculate cumulative zone of influence for multiple influence radii,
# using a circle neighborhood
cumzoi_circle <- calc_zoi_cumulative(cabins, type = "circle", radius = zoi_values)
plot(cumzoi_circle)

# calculate cumulative zone of influence for multiple influence radii,
# using an exponential decay neighborhood
cumzoi_exp <- calc_zoi_cumulative(cabins, type = "exp_decay", radius = zoi_values)
plot(cumzoi_exp)

# comparing
plot(c(cumzoi_gauss[[3]], cumzoi_circle[[3]], cumzoi_exp[[3]]),
     main = c("Gaussian 1000m",
              "Circle 1000m",
              "Exponential decay 1000m"))

# calculate cumulative influence for a single zone of influence
# using a user-defined filter
my_filter <- filter_create(cabins, radius = 1000, type = "rectangle")
cumzoi_user <- calc_zoi_cumulative(cabins, type = "mfilter", radius = my_filter)
plot(cumzoi_user, main = "User-defined rectangular filter")

# calculate density with 1000m radius using an exp_decay neighborhood
density_exp <- calc_zoi_cumulative(cabins, type = "exp_decay", radius = 1000,
                                   output_type = "density")
# compare
# note the difference in the color scales
plot(c(cumzoi_exp[[3]], density_exp),
     main = c("Cumulative ZoI 1000m", "Density 1000m"))

#--------------------
# Running calc_zoi_cumulative through GRASS GIS
library(rgrass7)
library(terra)

# Load raster data
f <- system.file("raster/cabins.tif", package = "oneimpact")
cabins <- terra::rast(f)

# connect to grass gis 7.8 and create grass location
# For linux or within OSGeo4W shell
grassdir <- system("grass78 --config path", intern = TRUE)
# If you used the standalone installer in Windows
# grassdir <- "C:\\Programs\\GRASS GIS 7.8" # Correct if the path is different

gisDB <- "." # create location and mapset in the working directory
loc <- "ETRS_33N/" # name of the location
ms <- "PERMANENT" # name of the mapset
rgrass7::initGRASS(gisBase = grassdir,
                   SG = cabins, # use map to define location projection
                   home = tempdir(),
                   override = TRUE,
                   gisDbase = gisDB,
                   location = loc,
                   mapset = ms)

# define map name within GRASS GIS
cabins_g <- "cabins_example"
# add file to GRASS GIS mapset
rgrass7::write_RAST(cabins, cabins_g, flags = c("o", "overwrite"))

# check
terra::plot(cabins, col = "black",
            main = "Map of tourist cabins")

#---
# define region in GRASS GIS
rgrass7::execGRASS("g.region", raster = cabins_g,
                   flags = "p")

#---
# Guarantee input map is binary (zeros as background)

# Input map name within GRASS GIS - binary map
cabins_bin_g <- grass_binarize(cabins_g, breaks = 1, output = "cabins_example_bin",
                               null = 0, overwrite = TRUE)

# check input
cabins_bin <- rgrass7::read_RAST("cabins_example_bin", return_format = "terra", NODATA = 255)

plot(cabins_bin, col = c("lightyellow", "black"),
     main = "Binarized map of cabins")

#---
# Using 'r.mfilter' algorithm (default)

# Exponential decay
exp_name <- calc_zoi_cumulative(x = cabins_bin_g,
                                radius = 1000, zoi_limit = 0.01,
                                type = "exp_decay",
                                where = "GRASS",
                                overwrite = TRUE, quiet = FALSE)
# Bartlett decay
barlett_name <- calc_zoi_cumulative(x = cabins_bin_g, radius = 1000,
                                    type = "bartlett",
                                    where = "GRASS",
                                    overwrite = TRUE, quiet = FALSE)
# Gaussian decay
gauss_name <- calc_zoi_cumulative(x = cabins_bin_g,
                                  radius = 1000, zoi_limit = 0.01,
                                  type = "Gauss",
                                  where = "GRASS",
                                  overwrite = TRUE, quiet = FALSE)

# Threshold decay (circle, step)
threshold_name <- calc_zoi_cumulative(x = cabins_bin_g, radius = 1000,
                                      type = "threshold",
                                      where = "GRASS",
                                      overwrite = TRUE, quiet = FALSE)

(all_names <- c(exp_name, barlett_name, gauss_name, threshold_name))

# visualize
cabins_zoi_cumulative <- rgrass7::read_RAST(all_names, return_format = "terra")

title_plot <- c("Exponential decay 1000m", "Bartlett decay 1000m",
                "Gaussian decay 1000m", "Threshold decay 1000m")
terra::plot(cabins_zoi_cumulative, main = title_plot)

#---
# calculate density vs cumulative ZoI
exp_name_d <- calc_zoi_cumulative(x = cabins_bin_g,
                                  radius = 1000, zoi_limit = 0.01,
                                  type = "exp_decay", output_type = "density",
                                  where = "GRASS",
                                  overwrite = TRUE, quiet = FALSE)

cabins_density <- rgrass7::read_RAST(exp_name_d, return_format = "terra")

terra::plot(c(cabins_zoi_cumulative[[1]], cabins_density),
            main = c("Cumulative ZoI", "Density"))

#---
# Using 'r.resamp.filter' algorithm

# rectangle
rectangle_resamp_filt <- calc_zoi_cumulative(x = cabins_bin_g,
                                             radius = 1000,
                                             type = "box",
                                             output_type = "density",
                                             where = "GRASS",
                                             module = "r.resamp.filter",
                                             overwrite = TRUE, quiet = FALSE)
rgrass7::read_RAST(rectangle_resamp_filt, return_format = "terra") |>
  plot(main = "Rectangle ZoI 1000m")

# bartlett
bartlett_resamp_filt <- calc_zoi_cumulative(x = cabins_bin_g,
                                            radius = 1000,
                                            type = "bartlett",
                                            output_type = "cumulative_zoi",
                                            where = "GRASS",
                                            module = "r.resamp.filter",
                                            overwrite = TRUE, quiet = FALSE)
rgrass7::read_RAST(bartlett_resamp_filt, return_format = "terra") |>
  plot(main = "Bartlett ZoI 1000m")

# Gaussian - to be implemented!
if(FALSE) {
  gauss_resamp_filt <- calc_zoi_cumulative(x = cabins_bin_g,
                                           radius = "1000,3000",
                                           type = "gauss,box",
                                           output_type = "cumulative_zoi",
                                           where = "GRASS",
                                           module = "r.resamp.filter",
                                           overwrite = TRUE, quiet = FALSE)
  rgrass7::read_RAST(bartlett_resamp_filt, return_format = "terra") |>
    plot()
}

# remove rasters created
to_remove_rast <- unique(c(all_names, exp_name_d,
                           rectangle_resamp_filt, bartlett_resamp_filt))
# rgrass7::execGRASS("g.remove", type = "vect", name = to_remove_vect, flags = "f")
# rgrass7::execGRASS("g.remove", type = "rast", name = to_remove_rast, flags = "f")
}
\seealso{
See \code{\link[=zoi_functions]{zoi_functions()}} for some ZoI function shapes and
\code{\link[=filter_create]{filter_create()}} for options to create weight matrices. \cr
See also \code{\link[smoothie:kernel2dmeitsjer]{smoothie::kernel2dmeitsjer()}}, \code{\link[terra:focalMat]{terra::focalMat()}}, and
\code{\link[raster:focalWeight]{raster::focalWeight()}} for other functions to create filters or weight matrices. \cr
See
\href{https://grass.osgeo.org/grass80/manuals/r.mfilter.html}{r.mfilter},
\href{https://grass.osgeo.org/grass80/manuals/r.resamp.filter.html}{r.resamp.filter}, and
\href{https://grass.osgeo.org/grass80/manuals/r.neighbors.html}{r.neighbors} for
GRASS GIS implementations of neighborhood analysis.\cr
See \code{\link[=calc_zoi_nearest]{calc_zoi_nearest()}} for the computation of the zone of influence
of the nearest feature only.
}
