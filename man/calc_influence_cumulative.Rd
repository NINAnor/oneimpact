% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calc_influence_cumulative.R
\name{calc_influence_cumulative}
\alias{calc_influence_cumulative}
\title{Calculate cumulative influence of multiple features}
\usage{
calc_influence_cumulative(
  x,
  zoi = 100,
  type = c("circle", "Gauss", "rectangle", "exp_decay", "bartlett", "threshold",
    "step", "mfilter")[1],
  where = c("R", "GRASS")[1],
  module = c("r.mfilter", "r.resamp.filter", "r.neighbors")[1],
  zoi_decay_threshold = 0.05,
  zoi_hl_ratio = NULL,
  half_life = NULL,
  exp_decay_parms = c(1, 0.01),
  min_intensity = 0.01,
  max_dist = 50000,
  normalize = FALSE,
  divisor = 1,
  extent_x_cut = NULL,
  extent_y_cut = NULL,
  na.policy = "omit",
  na.rm = TRUE,
  plotit = FALSE,
  parallel = TRUE,
  output_map_name = NULL,
  remove_intermediate = TRUE,
  overwrite = FALSE,
  quiet = TRUE,
  ...
)
}
\arguments{
\item{x}{\verb{[RasterLayer,SpatRaster,character]} \cr Raster representing locations of features,
preferentially a binary map with 1 where the features are located and 0 elsewhere.
Can be a \link{RasterLayer} from \link{raster} package or a \link{SpatRaster} from  \link{terra} package.
If \code{where = "GRASS"}, \code{x} must be a string corresponding to the name of the input map within
a GRASS GIS mapset. Continuous or discrete raster maps with multiple categories can be binarized
to be used as input for \code{calc_influence_cumulative} through \code{\link[landscapetools:util_binarize]{landscapetools::util_binarize()}}
in R or \link{util_binarize_GRASS} in GRASS GIS, or through common raster algebra in both
environments.}

\item{zoi}{\verb{[numeric(1)=100]} \cr Scale of the neighborhood analysis, used to calculate densities.
It can be a single value of a vector of values, in which case several density maps (for each scale)
are created. For \code{type = "circle"}, scale corresponds to the radius of the circle filter. For \code{type = "Gauss"},
it corresponds to the standard deviation of the Gaussian distribution. If \code{type = "rectangle"}, it corresponds
to the size of the side of a square filter. See \code{\link[terra:focalMat]{terra::focalMat()}} for more details.
If \code{type = "mfilter"}, scale is not a numeric value but a matrix itself, defined by the user. See description
in the details.}

\item{type}{\verb{[character(1)="circle"]\{"circle", "Gauss", "rectangle", "exp_decay", "bartlett", "threshold", "step", "mfilter"\}} \cr
Type of filter used to calculate density. See description for details.}

\item{extent_x_cut, entent_y_cut}{\verb{[numeric vector(2)=c(0,1)]} \cr Vector representing the minimum and
maximum extent in x and y for the final output, in the format c(min,max). It is intended to keep only
a region of interest but consider the surroundings when calculating densities. The default is to
keep the same extent of the input raster.}

\item{na.rm}{\verb{[logical(1)=FALSE]} \cr Should missing values be removed for filtering calculations?
Option for the neighborhood analysis, performed through the \code{\link[terra:focal]{terra::focal()}} function.}

\item{plotit}{\verb{[logical(1)=FALSE]} \cr Should the outputs be plotted along the calculation?}

\item{...}{Other arguments to be used within \code{\link[=create_filter]{create_filter()}} or \code{\link[terra:focal]{terra::focal()}}.}
}
\value{
A \link{RasterLayer} or \link{SpatRaster} (according to the input \code{x} map) with the density of features.
Alternatively, a \code{RasterBrick}
or multi-layer \code{SpatRaster}, if multile \code{zoi} values are given, with the density of features for all scales selected.
}
\description{
r.resamp.filter resamples an input raster, filtering the input with an analytic kernel.
Each output cell is typically calculated based upon a small subset of the input cells,
not the entire input. r.resamp.filter performs convolution (i.e. a weighted sum is
calculated for every raster cell).
}
\details{
This function takes in a raster with locations of infrastructure and calculates
a raster (or set of rasters, in case there is more the one value for \code{zoi})
representing the density of features in space (through a spatial filter/neighborhood analysis).
The neighborhood analysis is done with the \code{\link[terra:focal]{terra::focal()}} function.

The neighborhood analysis can be done with different methods. The default is a circular filter
(\code{type = "circle"}), in which case the parameter \code{zoi} corresponds to the radius of the circle
centered on the central pixel. Other possibilities are a Gaussian filter
(\code{type = "Gauss"}), in which case scale corresponds to the sigma parameter of a Gaussian
functionl and \code{type = "rectangle"}, in which case the scale corresponds to the
size size of the rectangle. For all these methods, these parameters feed the function
\code{\link[terra:focalMat]{terra::focalMat()}} to create the input weight matrix. See \code{\link[terra:focalMat]{terra::focalMat()}} for more
details.

If one wants to use their own filter or weight matrix, it is possible to define \code{type = "mfilter"}
and provide a matrix to the parameter \code{zoi} instead, such as one created through the
\code{\link[terra:focalMat]{terra::focalMat()}} or the \code{\link[=create_filter]{create_filter()}} functions.

TO IMPROVE1: Do not forget to mention the edge effects in r.mfilter in GRASS

TO IMPROVE2: do the same in communication with GRASS GIS.
}
\examples{
# Running calc_influence_cumulative through R
library(mobsim)
library(terra)

set.seed(1234)

# set points
ext <- 30000
wd <- ext/20
pts <- set_points(n_features = 1000, centers = 1,
                  width = wd, res = 100,
                  extent_x = c(0, ext), extent_y = c(0, ext),
                  buffer_around = 10000)#, use_terra = F)
plot(pts$pts)
plot(pts$rast)

# calculate cumulative influence for multiple zones of influence,
# considering only the initial extent, for a Gaussian filter
zoi_values <- c(250, 500, 1000, 2500, 5000)
cuminf_gauss <- calc_influence_cumulative(pts$rast, type = "Gauss", zoi = zoi_values,
                                    extent_x_cut = c(0, ext), extent_y_cut = c(0, ext))
plot(cuminf_gauss)

# calculate cumulative influence for multiple zones of influence,
# using a circle neighborhood
zoi_values <- c(250, 500, 1000, 2500, 5000)
cuminf_circle <- calc_influence_cumulative(pts$rast, type = "circle", zoi = zoi_values,
                                           extent_x_cut = c(0, ext), extent_y_cut = c(0, ext))
plot(cuminf_circle)

# calculate cumulative influence for a single zones of influence
# using a user-defined filter
my_filter <- create_filter(pts$rast, zoi = 1000, method = "exp_decay")
cuminf_user <- calc_influence_cumulative(pts$rast, type = "mfilter", zoi = my_filter,
                                        extent_x_cut = c(0, ext), extent_y_cut = c(0, ext))
plot(c(cuminf[[3]], cuminf_circle[[3]], cuminf_user),
     main = c("Gaussian filter", "Circle neighborhood", "User-defined filter"))

# calculate cumulative influence for multiple zones of influence,
# using an exp_decay neighborhood
zoi_values <- c(250, 500, 1000, 2500, 5000)
cuminf_exp <- calc_influence_cumulative(pts$rast, type = "exp_decay", zoi = zoi_values,
                                        extent_x_cut = c(0, ext), extent_y_cut = c(0, ext))
plot(cuminf_exp)

#--------------------
# Running calc_influence_cumulative through GRASS GIS
library(rgrass7)
library(raster)
library(terra)
library(dplyr)

# connect to grass gis 7.8
grassdir <- system("grass78 --config path", intern = T)
gisDB <- "/data/grass"
loc <- "ETRS_33N/"
ms <- "u_bb_cuminf"
rgrass7::initGRASS(gisBase = grassdir,
                   home = tempdir(),
                   override = T,
                   gisDbase = gisDB,
                   location = loc,
                   mapset = ms)

# Load raster data
f <- system.file("raster/cabins.tif", package = "oneimpact")
cabins_sp <- raster::raster(f) \%>\%
  as("SpatialPixelsDataFrame")
# define map name within GRASS GIS
cabins_g <- "private_cabins_sub"
# add file to GRASS GIS mapset
rgrass7::use_sp()
rgrass7::writeRAST(cabins_sp, cabins_g, overwrite = TRUE)

# check
cabins <- cabins_sp \%>\%
  raster::raster() \%>\%
  terra::rast()
terra::plot(cabins, col = "black",
            main = "Map of cabins")

#---
# define region in GRASS GIS
rgrass7::execGRASS("g.region", raster = cabins_g,
                   flags = "p")

# Input map name within GRASS GIS - binary map
cabins_bin_g <- util_binarize_GRASS(cabins_g, output = "private_cabins_bin",
                                    null = 0, overwrite = TRUE)

# check input
cabins_bin <- rgrass7::readRAST(cabins_bin_g) \%>\%
  raster::raster() \%>\%
  terra::rast()
plot(cabins_bin, col = c("lightyellow", "black"),
     main = "Binarized map of cabins")

# Exponential decay
exp_name <- calc_influence_cumulative(x = cabins_bin_g, zoi = 1000,
                                      zoi_decay_threshold = 0.01, type = "exp_decay",
                                      where = "GRASS", overwrite = T, quiet = F)
# Bartlett decay
barlett_name <- calc_influence_cumulative(x = cabins_bin_g, zoi = 1000, type = "bartlett",
                                      where = "GRASS", overwrite = T, quiet = F)
# Gaussian decay
gauss_name <- calc_influence_cumulative(x = cabins_bin_g, zoi = 1000,
                                        zoi_decay_threshold = 0.01, type = "Gauss",
                                        where = "GRASS", overwrite = T, quiet = F)
# Threshold decay (circle, step)
threshold_name <- calc_influence_cumulative(x = cabins_bin_g, zoi = 1000, type = "threshold",
                                            where = "GRASS", overwrite = T, quiet = F)

(all_names <- c(exp_name, barlett_name, gauss_name, threshold_name))

# visualize
cabins_influence_cumulative <- rgrass7::readRAST(all_names) \%>\%
  raster::stack() \%>\%
  terra::rast()

title_plot <- c("Exponential decay 1000m", "Bartlett decay 1000m",
                "Gaussian decay 1000m", "Threshold decay 1000m")
terra::plot(cabins_influence_cumulative, main = title_plot)

# remove rasters created
to_remove_vect <- c(test_region_name, cabins_vect_name)
to_remove_rast <- c(all_names)
# rgrass7::execGRASS("g.remove", type = "vect", name = to_remove_vect, flags = "f")
# rgrass7::execGRASS("g.remove", type = "rast", name = to_remove_rast, flags = "f")
}
