% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/set_points.R
\name{set_points}
\alias{set_points}
\title{Simulate points in a landscape}
\usage{
set_points(
  n_features = 1000,
  method = c("mobsim", "regular", "random", "raster")[1],
  centers = 1,
  width = 0.05,
  base_raster = NULL,
  point_coordinates = NULL,
  res = 0.1,
  extent_x = c(0, 1),
  extent_y = c(0, 1),
  buffer_around = 0,
  return_base_raster = TRUE,
  use_terra = TRUE,
  crs = ""
)
}
\arguments{
\item{n_features}{\verb{[integer(1)=1000]} \cr Total number of features to spread in space.}

\item{method}{\verb{[character(1)]\{"mobsim", "regular", "random", "raster"\}} \cr Method used
to simulate points in space.
\code{mobsim} uses the function \code{\link[mobsim:sim_thomas_community]{mobsim::sim_thomas_community()}} from the \link{mobsim} package to simulate
points. \code{raster} uses a base raster map as input to define weights and simulate the random points.}

\item{centers}{\verb{[integer(1)=1]} \cr Number of centers around which the features will be placed.
Used only if \code{method = "mobsim"}.}

\item{width}{\verb{[numeric(1)=0.05]} \cr Mean distance between each of the features in a cluster
and the center of the cluster. Used only if \code{method = "mobsim"}.}

\item{base_raster}{\verb{[RasterLayer=NULL]} \cr Base raster to define weights for creating the random points.
Used only if \code{method = "raster"}.}

\item{point_coordinates}{\verb{[data.frame=NULL]} \cr \code{data.frame} with (x,y) columns with coordinates
already taken from elsewhere. This option is intended for when the points' coordinates were already
generated or taken from a real landscape. In this case, no points are simulated and they are
just rasterized (so that distances or other derived variables might be calculated).}

\item{res}{\verb{[numeric(1)=0.1]} \cr Resolution of the output raster.}

\item{extent_x, entent_y}{\verb{[numeric vector(2)=c(0,1)]} \cr Vector representing the minimum and
maximum extent in x and y within which the points should be placed, in the format c(min,max).}

\item{buffer_around}{\verb{[numeric(1)=0.1]} \cr Size of the buffer around the extent of the landscape,
to avoid edge effects when calculating densities using neighborhood analysis.}

\item{return_base_raster}{\verb{[logical(1)=TRUE]} \cr Whether the base_raster should be returned in
the output list. This is \code{NULL} for \code{method = "mobsim"}.}

\item{use_terra}{\verb{[logical(1)=TRUE]} \cr If \code{TRUE} (default), the \code{rast} element
created from the points is a \code{SpatRaster} object
from \code{terra} package is created. If \code{FALSE}, it is a \code{RasterLayer} from \code{raster} package
is created.}

\item{crs}{\verb{[character(1)]} \cr Specification for the coordinate reference system
of the \code{rast} object created from the points. Default is
\code{"+proj=utm +zone=1 +datum=WGS84"}.
argument.}
}
\value{
A list with three elements: (1) \code{pts}, the coordinates (x,y) of the simulated points;
(2) \code{rast}, a binary raster containing the landscape, with 1 where there points and NA elsewhere;
(3) \code{base_rast}, the base raster used to weigh the simulation of points. If \code{method = "mobsim"}
or \code{"regular"} or \code{"random"}, \code{base_rast} is \code{NULL}.
}
\description{
This function simulates point patterns in space and rasterize them.
The idea is to mimic the spatial distribution of point-type infrastructure,
such as houses, cabins, or turbines, for instance.
The function returns a list with the position of the points and a binary raster
with 1 where there are points and NA elsewhere. If created with a raster to define
the weights, this base raster is also returned in the output.
}
\details{
If \code{method = "mobsim"}, the function builds upon the function
\code{\link[mobsim:sim_thomas_community]{mobsim::sim_thomas_community()}} from the \link{mobsim}
package. Originally the function is intended to simulate positions of multiple
species in the context of species abundance distribution studies, but it fits
well in case of a single species (or point patterns for a single type of feature).
In this case, the points are simulated based on the number of centers/patches of points
and their width.

If \code{method = "raster"}, the function uses an input raster (defined by the argument
\code{base_raster}) to define the probabilities of setting a given point in a certain pixel
in space.
}
\examples{
#-----
# using mobsim
library(terra)
library(mobsim)

set.seed(1234)

# gradient distribution
ext <- 30000
wd <- ext/5
pts <- set_points(n_features = 1000, centers = 1,
                  width = wd, res = 100,
                  extent_x = c(0, ext), extent_y = c(0, ext))
plot(pts$pts)
plot(pts$rast, col = "black")

# one focus of features, with buffer around
wd <- ext/20
pts <- set_points(n_features = 1000, centers = 1,
                  width = wd, res = 100,
                  extent_x = c(0, ext), extent_y = c(0, ext),
                  buffer_around = 10000)
plot(pts$pts)
plot(pts$rast, col = "black")

#-----
# using base raster

# raster
set.seed(12)
r <- raster::raster(matrix(runif(12),3,4)) |>
  raster::disaggregate(fact = 10)

# points from raster
pts <- set_points(n_features = 100, method = "raster",
                  base_raster = r)
plot(pts$base_rast)
plot(pts$pts)
plot(pts$rast, col = "black")

#-----
# using random or regular

set.seed(123)
ext <- 30000
pts <- set_points(n_features = 1000, method = "random",
                  res = 100,
                  extent_x = c(0, ext), extent_y = c(0, ext))
plot(pts$pts)
plot(pts$rast, col = "black")

pts <- set_points(n_features = 1000, method = "regular",
                  res = 100,
                  extent_x = c(0, ext), extent_y = c(0, ext))
plot(pts$pts)
plot(pts$rast, col = "black")

#-----
# using point coordinates as input
pt_input <- data.frame(x = c(0.5, 0.7), y = c(0.5, 0.3))
pts <- set_points(point_coordinates = pt_input)
plot(pts$pts)
plot(pts$rast, col = "black")
}
