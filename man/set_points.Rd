% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/set_points.R
\name{set_points}
\alias{set_points}
\title{Simulate points in a landscape}
\usage{
set_points(
  n_features = 1000,
  method = c("mobsim", "regular", "random", "raster", "NLMR")[1],
  centers = 1,
  width = 0.05,
  base_raster = NULL,
  nlmr_function = "nlm_mpd",
  point_coordinates = NULL,
  res = 0.1,
  extent_x = c(0, 1),
  extent_y = c(0, 1),
  buffer_around = 0,
  return_base_raster = TRUE,
  ...
)
}
\arguments{
\item{n_features}{\verb{[integer(1)=1000]} \cr Total number of features to spread in space.}

\item{method}{\verb{[character(1)]\{"mobsim", "regular", "random", "raster", "NLMR"\}} \cr Method used
to simulate points in space.
\code{mobsim} uses the function \code{\link[mobsim:sim_thomas_community]{mobsim::sim_thomas_community()}} from the \link{mobsim} package to simulate
points. \code{raster} uses a base raster map as input to define weights and simulate the random points.
\code{NLMR} creates a neutral landscape model using \link{NLMR} package and uses it as an input base raster.
See \code{Details} for more information.}

\item{centers}{\verb{[integer(1)=1]} \cr Number of centers around which the features will be placed.
Used only if \code{method = "mobsim"}.}

\item{width}{\verb{[numeric(1)=0.05]} \cr Radius of the "patches" of features, around the "patch" centers.
Used only if \code{method = "mobsim"}.}

\item{base_raster}{\verb{[RasterLayer=NULL]} \cr Base raster to define weights for creating the random points.
Used only if \code{method = "raster"}.}

\item{nlmr_function}{\verb{[character(1)="nlm_mpd"]} \cr Name of the function from NLMR package used to create
the base raster, to be used to define weights for creating the random points.
Used only if \code{method = "NLMR"}.}

\item{point_coordinates}{\verb{[data.frame=NULL]} \cr \code{data.frame} with (x,y) columns with coordinates
already taken from elsewhere. This option is intended for when the points' coordinates were already
generated or taken from a real landscape. In this case, no points are simulated and they are
just rasterized (so that distances or other derived variables might be calculated).}

\item{res}{\verb{[numeric(1)=0.1]} \cr Resolution of the output raster.}

\item{extent_x, entent_y}{\verb{[numeric vector(2)=c(0,1)]} \cr Vector representing the minimum and
maximum extent in x and y within which the points should be placed, in the format c(min,max).}

\item{buffer_around}{\verb{[numeric(1)=0.1]} \cr Size of the buffer around the extent of the landscape,
to avoid edge effects when calculating densities using neighborhood analysis.}

\item{return_base_raster}{\verb{[logical(1)=TRUE]} \cr Whether the base_raster should be returned in
the output list. This is \code{NULL} for \code{method = "mobsim"}.}

\item{...}{Other arguments passed as input to the NLMR functions, defined by the \code{nlmr_function}
argument.}
}
\value{
A list with three elements: (1) \code{pts}, the coordinates (x,y) of the simulated points;
(2) \code{rast}, a binary raster containing the landscape, with 1 where there points and NA elsewhere;
(3) \code{base_rast}, the base raster used to weigh the simulation of points. If \code{method = "mobsim"},
\code{base_rast} is \code{NULL}.
}
\description{
This function simulates point patterns in space and rasterize them.
The idea is to mimic the spatial distribution of point-type infrastructure,
such as houses, cabins, or turbines, for instance.
The function returns a list with the position of the points and a binary raster
with 1 where there are points and NA elsewhere. If created with a raster to define
the weights, this base raster is also returned in the output.
}
\details{
If \code{method = "mobsim"}, the function builds upon the function
\code{\link[mobsim:sim_thomas_community]{mobsim::sim_thomas_community()}} from the \link{mobsim}
package. Originally the function is intended to simulate positions of multiple
species in the context of species abundance distribution studies, but it fits
well in case of a single species (or point patterns for a single type of feature).
In this case, the points are simulated based on the number of centers/patches of points
and their width.

If \code{method = "raster"}, the function uses an input raster (defined by the argument
\code{base_raster}) to define the probabilities of setting a given point in a certain pixel
in space.

If \code{method = "NLMR"}, the function also uses a raster to define the probabilities of
setting a given point in a certain pixel in space, but this raster is created with
a function from the \link{NLMR} package. The function name is defined by the argument
\code{nlmr_function} and its arguments must be defined as additional parameters to
\code{set_points()}.

TO IMPROVE: implement rasterization with terra package
}
\examples{
#-----
# using mobsim
library(raster)
library(mobsim)

set.seed(1234)

# gradient distribution
ext <- 30000
wd <- ext/5
pts <- set_points(n_features = 1000, centers = 1,
                  width = wd, res = 100,
                  extent_x = c(0, ext), extent_y = c(0, ext))
plot(pts$pts)
plot(pts$rast, col = "black")

# one focus of features, with buffer around
wd <- ext/20
pts <- set_points(n_features = 1000, centers = 1,
                  width = wd, res = 100,
                  extent_x = c(0, ext), extent_y = c(0, ext),
                  buffer_around = 10000)
plot(pts$pts)
plot(pts$rast, col = "black")

#-----
# using base raster
library(dplyr)

# raster
set.seed(12)
r <- raster::raster(matrix(runif(12),3,4)) \%>\% 
  raster::disaggregate(fact = 10)

# points from raster
pts <- set_points(n_features = 100, method = "raster",
                  base_raster = r)
plot(pts$base_rast)
plot(pts$pts)
plot(pts$rast, col = "black")

#-----
# using NLMR
library(NLMR)

# example NLM
set.seed(123)
ext <- 300
nlm1 <- NLMR::nlm_mpd(ext, ext, 100, roughness = .5)
nlm1[] <- scales::rescale(exp(nlm1[]))

plot(nlm1)

# points
pts <- set_points(n_features = 1000, method = "raster",
                  base_raster = nlm1)

plot(pts$base_rast)
plot(pts$pts)
plot(pts$rast, col = "black")

# OR we can do it directly

# points
ext <- 30000
pts <- set_points(n_features = 10000, method = "NLMR",
                  nlmr_function = "nlm_mpd",
                  roughness = .2,
                  res = 100,
                  extent_x = c(0, ext), extent_y = c(0, ext))

plot(pts$base_rast)
plot(pts$pts)
plot(pts$rast, col = "black")

#-----
# using random or regular

set.seed(123)
ext <- 30000
pts <- set_points(n_features = 1000, method = "random",
                  res = 100,
                  extent_x = c(0, ext), extent_y = c(0, ext))
plot(pts$pts)
plot(pts$rast, col = "black")

pts <- set_points(n_features = 1000, method = "regular",
                  res = 100,
                  extent_x = c(0, ext), extent_y = c(0, ext))
plot(pts$pts)
plot(pts$rast, col = "black")

#-----
# using point coordinates as input
pt_input <- data.frame(x = c(0.5, 0.7), y = c(0.5, 0.3))
pts <- set_points(point_coordinates = pt_input)
plot(pts$pts)
plot(pts$rast, col = "black")
}
