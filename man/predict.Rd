% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bag_predict.R
\name{predict}
\alias{predict}
\alias{predict.bag}
\alias{predict.formula}
\title{Prediction of a bag of models to new data}
\usage{
predict(
  x,
  newdata,
  type = c("linear", "exponential", "exp", "logit", "cloglog")[1],
  wmean = TRUE,
  wq_probs = NULL,
  include = "all",
  ...
)

\method{predict}{bag}(
  x,
  newdata,
  data = NULL,
  type = c("linear", "exponential", "exp", "logit", "cloglog")[1],
  wmean = TRUE,
  wq_probs = NULL,
  include = "all",
  baseline = c("median", "mean", "zero")[1],
  zoi = FALSE,
  zoi_shape = c("exp_decay", "gaussian_decay", "linear_decay", "threshold_decay")[1],
  which_cumulative = "cumulative",
  type_feature = c("point", "line", "area")[1],
  n_features = 1,
  resolution = 100,
  line_value = 1,
  ...
)

\method{predict}{formula}(
  x,
  newdata,
  coefs,
  weights = 1,
  type = c("linear", "exponential", "exp", "logit", "cloglog")[1],
  wmean = TRUE,
  wq_probs = NULL,
  include = "all",
  ...
)
}
\arguments{
\item{x}{\verb{[bag,list or formula]} \cr  A bag of models, resulting from a call to \code{\link[=bag_models]{bag_models()}},
or a \code{formula} used to fit the models in the bag.}

\item{newdata}{\cr New data set to be used for prediction. It can include all the variables in the formula
or only those for which the user is interested in making a prediction from.}

\item{type}{\verb{[character="linear"]\{"linear", "exponential", "exp", "logit", "cloglog"\}} \cr Type of prediction.
One of \code{"linear"} (default), \code{"exp"} or \code{"exponential"}, \code{"logit"}, or \code{"cloglog"}.}

\item{wmean}{\verb{[logical=TRUE]} \cr Should the weighted mean values be predicted? Default is \code{TRUE}.}

\item{wq_probs}{\verb{[vector,numeric(3)=c(0.025, 0.5, 0.975)]} \cr A three element vector with lower,
mid, and higher weighted quantiles to be computed.}

\item{include}{\verb{[character="all"]} \cr String of vector of strings with the terms (or unique parts of terms)
to be predicted for. This does not restrict which terms we are focusing on - this is done
by the definition of the \code{newdata} dataset and by which columns are in there. What
the \code{include} parameters does is to set which other variables will be used for prediction,
at their mean or median values, for instance.}

\item{...}{\cr Additional parameters. None implemented.}

\item{baseline}{\verb{[character="median"]\{"median", "mean", "zero")\}} \cr What values to
choose for the baseline, i.e., for all other variables/terms not contained in
\code{newdata}. It can be one of \code{median}, \code{"mean"}, or \code{"zero"}.}

\item{zoi}{\verb{[logical(1)=FALSE]} \cr Are the columns in \code{newdata} supposed to represent
zones of influence (ZOI) variables?
This parameter should be set to \code{TRUE} if you provided a set of distances from a source that need
to be translated into ZOI variables (cumulative or nearest ZOI from sources).}

\item{zoi_shape}{\verb{[character="exp_decay"]\{"exp_decay", "gaussian_decay", "linear_decay", "threshold_decay"\}} \cr
Shape of the zone of influence (ZOI), if \code{zoi = TRUE}. Default is \verb{exp_decay"}. It can assume any of the
possible values for the argument \code{type} in the function \code{\link[=dist_decay]{dist_decay()}}.}

\item{which_cumulative}{\verb{[character="cumulative"]} \cr Which string or pattern to be searched on the column
names of \code{newdata} and on the original data used to fit the models to represent the cumulative ZOI.
It is used to break the names of the columns/terms in the formula and get the ZOI radii as numbers,
to be able to create all the ZOI radii included in the model or bag of models.}

\item{type_feature}{\verb{[character="point"]\{"point", "line", "area"\}} \cr Type of feature we are predicting
for, for zone of influence-type variables. Default is \code{"point"}. If \code{type_feature = "line"}, a line is simulated
with the function \code{\link[=create_linear_feature_zoi]{create_linear_feature_zoi()}} to get the values and account for
the number of pixels of each single linear feature in the neighborhhod and correclty estimate
the effect of each linear feature ZOI. The option \code{"area"} is still not implemented and for now
is treated as a point feature at the origin.}

\item{n_features}{\verb{[numeric(1)=1]} \cr Number of features to be used for prediction, for ZOI variables.
Default is 1.}

\item{resolution}{\verb{[numeric(1)=100]} \cr Resolution for the raster created in \code{\link[=create_line_feature_zoi]{create_line_feature_zoi()}},
when \code{type_feature = "line"}.}

\item{line_value}{\verb{[numeric(1)=1]} \cr Value set to the raster line created by \code{\link[=create_line_feature_zoi]{create_line_feature_zoi()}},
when \code{type_feature = "line"}. It could be changed to different values if we want to represent e.g. the value in the
linear feature as the roads traffic or another value for spatio-temporally dynamic variables.}

\item{coefs}{\verb{[vector,numeric]} \cr Either a named vector of coefficients (in case there is only one
model) or a matrix of coefficients, with rownames as the term names and columns as the different models/resamples.
Only relevant if \code{x} is a formula.}

\item{weights}{\verb{[vector,numeric=1]} \cr Vector of weights for the different models/resamples, i.e.
the column from the \code{coefs} object with coefficients. A single number (by default, 1) in case there is only
one model (\code{coefs} is a vector). Only relevant if \code{x} is a formula.}
}
\description{
The function \code{predict} makes a prediction for new data based wither on a bag of models or
on its formula, coefficients, and weights. The prediction can be made either for a complete new dataset
with all the variables included in the formula or to predict the specific response on one single or a
group of variables in the model. In this case, all the other variables are set to their median or mean
value, to to zero (defined by the \code{baseline} parameter). What controls that is which columns are added in
the \code{newdata} data.frame.
}
\examples{
#---
# fit a bag to be tested

# load packages
library(glmnet)

# load data
data("reindeer_rsf")
# rename it just for convenience
dat <- reindeer_rsf

# formula initial structure
f <- use ~ private_cabins_XXX + public_cabins_high_XXX +
  NORUTreclass +
  # poly(norway_pca_klima_axis1, 2, raw = TRUE) +
  # poly(norway_pca_klima_axis2, 2, raw = TRUE) +
  norway_pca_klima_axis1 + norway_pca_klima_axis1_sq +
  norway_pca_klima_axis2 + norway_pca_klima_axis2_sq +
  norway_pca_klima_axis3 + norway_pca_klima_axis4

# add ZOI terms to the formula
zois <- c(100, 250, 500, 1000, 2500, 5000, 10000, 20000)
f <- add_zoi_formula(f, zoi_radius = zois, pattern = "XXX",
                     type = c("cumulative_exp_decay"),
                     separator = "_", predictor_table = TRUE)$formula

# sampling - random sampling
set.seed(1234)
samples <- create_resamples(y = dat$use,
                            p = c(0.2, 0.2, 0.2),
                            times = 10,
                            colH0 = NULL)

# fit multiple models
fittedl <- bag_fit_net_logit(f,
                             data = dat,
                             samples = samples,
                             standardize = "internal", # glmnet does the standardization of covariates
                             metric = "AUC",
                             method = "AdaptiveLasso",
                             parallel = "mclapply",
                             mc.cores = 2)

# bag models in a single object
bag_object <- bag_models(fittedl, dat, score_threshold = 0.7)

#---
# prediction using formula

# new data, looking only at PCA1
dfvar = data.frame(norway_pca_klima_axis1 = seq(min(bag_object$data_summary$norway_pca_klima_axis1),
                                                max(bag_object$data_summary$norway_pca_klima_axis1),
                                                length.out = 100))
dfvar$norway_pca_klima_axis1_sq = dfvar$norway_pca_klima_axis1**2

# one model only
bag_predict(x = f,
            newdata = dfvar,
            coefs = bag_object$coef[,1],
            include = "axis1")

# whole bag, weighted mean - here all weights = 1
bag_predict(x = f,
            newdata = dfvar,
            coefs = bag_object$coef,
            include = names(dfvar))

# whole bag, for each model separately
bag_predict(x = f,
            newdata = dfvar,
            coefs = bag_object$coef,
            wmean = FALSE,
            include = names(dfvar))

#---
# prediction using bag

# prediction for the very same dataset, linear scale
bag_predict(x = bag_object,
            newdata = dat,
            data = dat)

# non ZOI variable
# new data, looking only at PCA3
dfvar = data.frame(norway_pca_klima_axis3 = seq(min(bag_object$data_summary$norway_pca_klima_axis3),
                                                max(bag_object$data_summary$norway_pca_klima_axis3),
                                                length.out = 100))

bag_predict(x = bag_object,
            newdata = dfvar,
            data = dat)

# ZOI variable
# new data, looking only at private cabins
dfvar = data.frame(private_cabins = 1e3*seq(0.2, 20, length.out = 100))

# prediction for 1 feature, linear scale
bag_predict(x = bag_object,
            newdata = dfvar,
            data = dat,
            zoi = TRUE,
            baseline = "zero")

# prediction for 30 features, exp scale, with weighted confidence intervals
bag_predict(x = bag_object,
            newdata = dfvar,
            data = dat,
            type = "exp",
            wq_probs = c(0.025, 0.975),
            zoi = TRUE,
            n_features = 30,
            baseline = "zero")

# plot
plot(dfvar[,1],
     bag_predict(x = bag_object,
                 newdata = dfvar,
                 data = dat,
                 type = "exp",
                 zoi = TRUE,
                 n_features = 30,
                 baseline = "zero")[,1])
}
\seealso{
\code{\link[=plot_response]{plot_response()}}, \code{\link[=create_line_feature_zoi]{create_line_feature_zoi()}}.
}
