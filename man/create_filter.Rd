% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_filter.R
\name{create_filter}
\alias{create_filter}
\title{Create filters or kernel matrices for raster neighborhood analyses}
\usage{
create_filter(
  r = 100,
  zoi = NULL,
  method = c("exp_decay", "bartlett", "circle", "threshold", "step", "Gauss",
    "rectangle")[1],
  zoi_decay_threshold = 0.05,
  half_life = NULL,
  zoi_hl_ratio = NULL,
  sigma = NULL,
  min_intensity = 0.01,
  max_dist = 5000,
  normalize = FALSE,
  divisor = 1,
  round_vals = NULL,
  save_txt = FALSE,
  save_format = c("GRASS_r.mfilter", "raw")[1],
  save_folder = NULL,
  save_file = NULL,
  output = c("CumInf", "Densiy")[1],
  parallel = TRUE
)
}
\arguments{
\item{r}{Either a numeric value corresponding to the resolution (pixel size) that each pixel in the filter matrix
should correspond to; or a raster object (\code{SpatRaster} from the \code{terra} package or \code{RasterLayer}, \code{RasterBrick}, or
\code{RasterStack} from the \code{raster} package) from which such resolution can be extracted.}

\item{zoi}{\verb{[numeric(1)=NULL]} \cr Zone of Influence (ZoI), in map units (preferentially meters).
The ZoI is the distance, scale, or buffer size around a feature up to which we consider there is
an effect or influence of an infrastructure or variable. \cr
For the circle neighborhood (equivalent to step or threshold neighborhoods), the \code{zoi} corresponds to the radius
(or thresold) of the circle, beyond which the filter is zero. \cr
For the rectangular neighborhood, the \code{zoi} corresponds to half the size of the square size, or
\verb{square size = 2*zoi}. For a rectangular filter with different size of the sides, use \code{\link[terra:focal]{terra::focal()}} (but
please note the interpretation of the parameters is different). \cr
For the Bartlett neighborhood, the \code{zoi} corresponds to the distance beyond which the filter is zero. \cr
For the exponential decay neighborhood, the \code{zoi} is used to define the half-life and the lambda
of the exponential decay function, based on the parameter \code{zoi_hl_ratio},
that defines the ratio between the ZoI and the exponential half-life. Since the half-life is the value
where the exponential decay decreases by \code{0.5}, a ratio of, for instance, \code{zoi_hl_ratio = 4} (default)
would mean that the ZoI is defined as the value where the exponential decay decreases to \code{0.5^4 = 0.0625}.
In this case, if \code{zoi = 4000} m, this means that the ZoI is four times higher than the half-life, i.e.
\code{half_life = 1000} and \code{lambda = log(2)/half_life = 6.93e-4}. The definition of a zone of
influence does not imply a cutoff of the exponential decay function but is only used to define
its parameters, based on the defined \code{zoi_hl_ratio} parameter. The cutoff is given either by the
\code{min_intensity} or the \code{max_dist} parameters.
If \code{zoi = NULL}, the exponential decay is defined based on the \code{half_life} parameter. \cr
Gaussian neighborhood with parameterization in terms of \code{zoi} to be implemented.}

\item{method}{\verb{[character(1)="exp_decay"]\{"exp_decay", "bartlett", "circle", "threshold", "step", "Gauss", "rectangle"\}} \cr
Rectangle = boxcar in smoothie::kernel2dmeitsjer
Gaussian neighborhood with parameterization in terms of \code{zoi} implemented, but with a differen parameterization
from \code{\link[terra:focalMat]{terra::focalMat()}} with parameter
\code{type = "Gauss"} and \code{\link[smoothie:kernel2dmeitsjer]{smoothie::kernel2dmeitsjer()}} with parameter \code{type = "gauss"} - we use zoi.}

\item{half_life}{\verb{[numeric(1)=NULL]} \cr Half life parameter of the exponential decay function, in meters. If NULL,
the half life is define in terms of the ZoI and the \code{zoi_hl_ratio} parameter, which defines the ratio
between the ZoI and the half life. By default, we set this ratio as \code{zoi/half_life = 4}.
The exponent of the exponential decay distance function is defined as \code{lambda = log(2)/half_life}.}

\item{zoi_hl_ratio}{\verb{[numeric(1)=6]} \cr Ratio between the ZoI and the half life of the exponential decay
distance function. It is used to define the ZoI for the exponential decay function. For instance, if
\code{half_life = 1000} and \code{zoi_hl_ratio = 4}, the ZoI will be 4000 m (when the exponential decay decrease to
\code{0.5**4 = 0.0625}.}

\item{min_intensity}{\verb{[numeric(1)=0.01]} \cr Minimum intensity of the exponential decay function to
define the size (radius) of the window that define the filter.}

\item{max_dist}{\verb{[numeric(1)=50000]} \cr Maximum size (in meters) to
define the size (radius) of the window that define the filter.}

\item{normalize}{\verb{[logical(1)=FALSE]} \cr Whether the matrix should be normalized (sum of all cell is 1, if
\code{normalize = TRUE}) or kept as it is (default, \code{normalize = FALSE}).}

\item{divisor}{\verb{[numeric(1)=1]} \cr By default, 1. This is the divisor of the neighborhood
matrix, when used within \code{r.mfilter}. According the the module documentation, "The filter process produces a new Â¨
category value for each cell in the input raster map layer by multiplying the category values of the cells
in the n x n neighborhood around the center cell by the corresponding matrix value and adding them together.
If a divisor is specified, the sum is divided by this divisor." \cr
If the divisor is zero, "then the divisor is computed for each cell as the sum of the MATRIX values where
the corresponding input cell is non-null." In other words, the output map will be rescaled to the
interval \link{0,1}. If \code{normalize = TRUE}, the divisor is set to \code{n*n}.}

\item{save_format}{\verb{[character(1)="GRASS_r.mfilter"]\{"GRASS_r.mfilter", "raw"\}} \cr
Format in which the function should be saved. Currently, only GRASS GIS format for the module \code{r.mfilter}
(\code{save_format = "GRASS_r.mfilter"}, according to the required format for \code{r.mfilter} module, details
\href{https://grass.osgeo.org/grass78/manuals/r.mfilter.html}{here}) or raw (\code{save_format = "raw"}),
in which only the values of the matrix are printed.}

\item{save_folder}{\verb{[character(1)=NULL]} \cr Path to the folder where the matrix file should be written.
If \code{NULL}, the current directory is used.}

\item{save_file}{\verb{[character(1)=NULL]} \cr Name of the output file, generally a ".txt" file.
If \code{NULL}, a standard filename is created, using the the \code{method} and \code{zoi}. E.g. "filter_bartlett2000.txt".}

\item{parallel}{\verb{[logical(1)=TRUE]} \cr Whether the computation should be paralelized or not (details in
the documentation of the \href{(https://grass.osgeo.org/grass78/manuals/r.mfilter.html)}{\code{r.mfilter}} module).}
}
\value{
A matrix with the weight values.
}
\description{
This function creates matrices of weights following different
functions to be used in neighborhood analyses for rasters. It is possible
to export these matrices as text files, for use with external softwares
such as the r.mfilter module within GRASS GIS.
}
\details{
\subsection{COMPARE WITH smoothie::kernel2dsmooth and smoothie::kernel2dmeitsjer, maybe wrap some options here}{
}

\subsection{POLSSIBLY: IMPLEMENT IN THE SAME WAY AS FOCAL, WITH INPUT RASTER AS ARGUMENT, POSSIBLY}{
}

\subsection{check: if the outer ring of the matrix is all zero, remove it}{
}
}
\examples{
library(terra)
library(dplyr)

# load example raster in metric system
f <- system.file("ex/elev.tif", package="terra")
r <- rast(f) \%>\%
  terra::project("EPSG:32631")
# terra::ext(r)[1:2] \%>\% diff

# create exponential filter
filt_exp1000 <- create_filter(r, zoi = 1000,
                              zoi_decay_threshold = 0.01,
                              method = "exp_decay",
                              max_dist = 5000,
                              normalize = T)
filt_exp3000 <- create_filter(r, zoi = 3000,
                              zoi_decay_threshold = 0.01,
                              method = "exp_decay",
                              max_dist = 5000,
                              normalize = T)
# use exponential filter
neigh_r_exp1000 <- terra::focal(r, filt_exp1000, fun = "sum",
                                na.policy = "omit", na.rm = TRUE)
neigh_r_exp3000 <- terra::focal(r, filt_exp3000, fun = "sum",
                                na.policy = "omit", na.rm = TRUE)

# plot
plot(c(r, neigh_r_exp1000, neigh_r_exp3000),
     main = c("original", "exp filter 1000m", "exp filter 3000m"))

# create step filter
filt_step3000 <- create_filter(r, zoi = 3000, method = "step",
                               normalize = T)
# use step filter
neigh_r_step3000 <- terra::focal(r, filt_step3000, fun = "sum",
                                 na.policy = "omit", na.rm = TRUE)

# plot
plot(c(neigh_r_exp3000, neigh_r_step3000),
     main = c("exp filter 3000m", "step filter 3000m"))
# plot(app(c(neigh_r_exp3000, neigh_r_step3000), "diff"))

# create bartlett filter
filt_bart3000 <- create_filter(r, zoi = 3000, method = "bartlett",
                               normalize = T)
# use bartlett filter
neigh_r_bart3000 <- terra::focal(r, filt_bart3000, fun = "sum",
                                 na.policy = "omit", na.rm = TRUE)

# create Gaussian filter - parameterized with zoi
filt_gauss3000 <- create_filter(r, zoi = 3000, method = "Gauss",
                                zoi_decay_threshold = 0.01,
                                normalize = T)
# use bartlett filter
neigh_r_gauss3000 <- terra::focal(r, filt_gauss3000, fun = "sum",
                                 na.policy = "omit", na.rm = TRUE)


# plot
plot(c(neigh_r_exp3000, neigh_r_step3000, neigh_r_bart3000, neigh_r_gauss3000),
     main = c("exp filter 3000m", "step filter 3000m",
              "Bartlett filter 3000m", "Gaussian filter 3000m"))
# plot(app(c(neigh_r_exp3000, neigh_r_bart3000), "diff"))
# plot(app(c(neigh_r_step3000, neigh_r_bart3000), "diff"))

# save outside R for use in GRASS GIS
# create_filter(r, zoi = 1000, method = "bartlett",
#               max_dist = 5000,
#               normalize = T, save_txt = TRUE)
}
\seealso{
See also \code{\link[smoothie:kernel2dmeitsjer]{smoothie::kernel2dmeitsjer()}}, \code{\link[terra:focalMat]{terra::focalMat()}}, and
\code{\link[raster:focalWeight]{raster::focalWeight()}} for other functions to create filters or weight matrices.
}
